<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>tree-sitter-ts-highlight â€” Interactive Demo</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0 20px 80px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0f0f14;
      color: #e6e6e6;
      line-height: 1.5;
    }
    .container { max-width: 1080px; margin: 0 auto; }
    h1 { margin: 40px 0 8px; font-size: 2rem; }
    .subtitle { color: #9aa0aa; margin-bottom: 28px; }
    .panel {
      border: 1px solid #25253a;
      border-radius: 10px;
      background: #141422;
      padding: 16px;
      margin-bottom: 16px;
    }
    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
      align-items: end;
    }
    label { font-size: 0.82rem; color: #9aa0aa; display: block; margin-bottom: 6px; }
    select, textarea, button, input[type="checkbox"] {
      font: inherit;
    }
    select, textarea {
      width: 100%;
      background: #0f1020;
      border: 1px solid #2a2a3a;
      color: #e6e6e6;
      border-radius: 8px;
      padding: 10px;
    }
    textarea { min-height: 200px; resize: vertical; font-family: 'SF Mono', Menlo, monospace; font-size: 13px; }
    button {
      background: #7aa2f7;
      border: none;
      color: #101420;
      border-radius: 8px;
      padding: 10px 14px;
      font-weight: 600;
      cursor: pointer;
    }
    .row { display: flex; gap: 18px; align-items: center; flex-wrap: wrap; }
    .check { display: flex; align-items: center; gap: 8px; color: #c8c8d4; }
    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    @media (max-width: 860px) { .grid-2 { grid-template-columns: 1fr; } }
    .grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; }
    @media (max-width: 860px) { .grid-3 { grid-template-columns: 1fr; } }
    .code-wrap pre {
      margin: 0;
      border-radius: 8px;
      overflow-x: auto;
      padding: 16px;
      font-size: 13px;
      line-height: 1.5;
      font-family: 'SF Mono', Menlo, monospace;
    }
    h2 { margin: 0 0 10px; font-size: 1.15rem; }
    .muted { color: #9aa0aa; font-size: 0.92rem; }
    ul { margin: 8px 0 0 18px; }
    .symbols-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    .symbols-table th, .symbols-table td {
      text-align: left;
      padding: 8px 10px;
      border-bottom: 1px solid #2a2a3a;
      font-family: 'SF Mono', Menlo, monospace;
      font-size: 12px;
    }
    .symbols-table th { color: #7aa2f7; font-size: 11px; text-transform: uppercase; letter-spacing: 0.04em; }
    .small { font-size: 0.8rem; color: #7f8694; }
    .diff-preview {
      border: 1px solid #2a2a3a;
      border-radius: 8px;
      overflow: auto;
    }
    .json-preview {
      margin: 0;
      padding: 12px;
      border: 1px solid #2a2a3a;
      border-radius: 8px;
      background: #0f1020;
      font-family: 'SF Mono', Menlo, monospace;
      font-size: 12px;
      max-height: 280px;
      overflow: auto;
      white-space: pre;
    }

/* tree-sitter-ts-highlight - Default Light Theme (One Light-inspired) */
.hlts.hlts-default-light {
  background: #fafafa;
  color: #383a42;
  font-family: 'SF Mono', 'Fira Code', 'Fira Mono', 'Roboto Mono', Menlo, Courier, monospace;
  font-size: 14px;
  line-height: 1.5;
  tab-size: 4;
  overflow-x: auto;
  padding: 16px;
  border-radius: 6px;
}

/* Token categories */
.hlts-default-light .hlts-keyword {
  color: #a626a4;
  font-weight: bold;
}
.hlts-default-light .hlts-identifier {
  color: #383a42;
}
.hlts-default-light .hlts-string {
  color: #50a14f;
}
.hlts-default-light .hlts-number {
  color: #986801;
}
.hlts-default-light .hlts-comment {
  color: #a0a1a7;
  font-style: italic;
}
.hlts-default-light .hlts-operator {
  color: #383a42;
}
.hlts-default-light .hlts-punctuation {
  color: #383a42;
}
.hlts-default-light .hlts-type {
  color: #c18401;
}
.hlts-default-light .hlts-decorator {
  color: #a626a4;
}
.hlts-default-light .hlts-tag {
  color: #e45649;
}
.hlts-default-light .hlts-attribute {
  color: #986801;
}
.hlts-default-light .hlts-meta {
  color: #a0a1a7;
}
.hlts-default-light .hlts-regexp {
  color: #50a14f;
}
.hlts-default-light .hlts-escape {
  color: #986801;
  font-weight: bold;
}
.hlts-default-light .hlts-variable {
  color: #e45649;
}
.hlts-default-light .hlts-constant {
  color: #986801;
}
.hlts-default-light .hlts-error {
  color: #e45649;
  text-decoration: wavy underline;
}
.hlts-default-light .hlts-plain {
  color: #383a42;
}

/* Line numbers (table layout) */
.hlts-default-light .hlts-table {
  border-collapse: collapse;
  width: 100%;
}
.hlts-default-light .hlts-line-number {
  color: #a0a1a7;
  border-right: 1px solid #e0e0e0;
  padding-right: 12px;
  padding-left: 8px;
  text-align: right;
  user-select: none;
  -webkit-user-select: none;
  width: 1%;
  vertical-align: top;
  white-space: nowrap;
}
.hlts-default-light .hlts-line-content {
  padding-left: 16px;
  white-space: pre;
}
.hlts-default-light .hlts-table tr:hover {
  background: rgba(0, 0, 0, 0.03);
}

/* Decoration utility classes */
.hlts-default-light .hlts-error-underline {
  text-decoration: wavy underline #e45649;
  text-underline-offset: 2px;
}
.hlts-default-light .hlts-highlight-line {
  background: rgba(255, 255, 0, 0.1);
}

/* Diff views */
.hlts-default-light .hlts-diff {
  border-collapse: collapse;
  width: 100%;
  table-layout: auto;
}
.hlts-default-light .hlts-diff-header .hlts-diff-label {
  text-align: left;
  font-weight: 600;
  padding: 6px 10px;
  border-bottom: 1px solid #e0e0e0;
}
.hlts-default-light .hlts-diff-gutter {
  color: #a0a1a7;
  text-align: right;
  user-select: none;
  -webkit-user-select: none;
  width: 1%;
  padding: 0 10px;
  vertical-align: top;
  white-space: nowrap;
}
.hlts-default-light .hlts-diff-content {
  white-space: pre;
  padding: 0 10px;
  vertical-align: top;
}
.hlts-default-light .hlts-diff-row.hlts-diff-context {
  background: transparent;
}
.hlts-default-light .hlts-diff-row.hlts-diff-added {
  background: rgba(46, 160, 67, 0.12);
}
.hlts-default-light .hlts-diff-row.hlts-diff-removed {
  background: rgba(207, 34, 46, 0.12);
}
.hlts-default-light .hlts-diff-row.hlts-diff-modified {
  background: rgba(191, 135, 0, 0.12);
}
.hlts-default-light .hlts-diff-sign {
  width: 24px;
  text-align: center;
  color: #6a737d;
  user-select: none;
  -webkit-user-select: none;
}

/* tree-sitter-ts-highlight - Default Dark Theme (One Dark-inspired) */
.hlts.hlts-default-dark {
  background: #282c34;
  color: #abb2bf;
  font-family: 'SF Mono', 'Fira Code', 'Fira Mono', 'Roboto Mono', Menlo, Courier, monospace;
  font-size: 14px;
  line-height: 1.5;
  tab-size: 4;
  overflow-x: auto;
  padding: 16px;
  border-radius: 6px;
}

/* Token categories */
.hlts-default-dark .hlts-keyword {
  color: #c678dd;
  font-weight: bold;
}
.hlts-default-dark .hlts-identifier {
  color: #abb2bf;
}
.hlts-default-dark .hlts-string {
  color: #98c379;
}
.hlts-default-dark .hlts-number {
  color: #d19a66;
}
.hlts-default-dark .hlts-comment {
  color: #5c6370;
  font-style: italic;
}
.hlts-default-dark .hlts-operator {
  color: #abb2bf;
}
.hlts-default-dark .hlts-punctuation {
  color: #abb2bf;
}
.hlts-default-dark .hlts-type {
  color: #e5c07b;
}
.hlts-default-dark .hlts-decorator {
  color: #c678dd;
}
.hlts-default-dark .hlts-tag {
  color: #e06c75;
}
.hlts-default-dark .hlts-attribute {
  color: #d19a66;
}
.hlts-default-dark .hlts-meta {
  color: #5c6370;
}
.hlts-default-dark .hlts-regexp {
  color: #98c379;
}
.hlts-default-dark .hlts-escape {
  color: #d19a66;
  font-weight: bold;
}
.hlts-default-dark .hlts-variable {
  color: #e06c75;
}
.hlts-default-dark .hlts-constant {
  color: #d19a66;
}
.hlts-default-dark .hlts-error {
  color: #e06c75;
  text-decoration: wavy underline;
}
.hlts-default-dark .hlts-plain {
  color: #abb2bf;
}

/* Line numbers (table layout) */
.hlts-default-dark .hlts-table {
  border-collapse: collapse;
  width: 100%;
}
.hlts-default-dark .hlts-line-number {
  color: #636d83;
  border-right: 1px solid #3b4048;
  padding-right: 12px;
  padding-left: 8px;
  text-align: right;
  user-select: none;
  -webkit-user-select: none;
  width: 1%;
  vertical-align: top;
  white-space: nowrap;
}
.hlts-default-dark .hlts-line-content {
  padding-left: 16px;
  white-space: pre;
}
.hlts-default-dark .hlts-table tr:hover {
  background: rgba(255, 255, 255, 0.03);
}

/* Decoration utility classes */
.hlts-default-dark .hlts-error-underline {
  text-decoration: wavy underline #e06c75;
  text-underline-offset: 2px;
}
.hlts-default-dark .hlts-highlight-line {
  background: rgba(255, 255, 0, 0.05);
}

/* Diff views */
.hlts-default-dark .hlts-diff {
  border-collapse: collapse;
  width: 100%;
  table-layout: auto;
}
.hlts-default-dark .hlts-diff-header .hlts-diff-label {
  text-align: left;
  font-weight: 600;
  padding: 6px 10px;
  border-bottom: 1px solid #3b4048;
}
.hlts-default-dark .hlts-diff-gutter {
  color: #636d83;
  text-align: right;
  user-select: none;
  -webkit-user-select: none;
  width: 1%;
  padding: 0 10px;
  vertical-align: top;
  white-space: nowrap;
}
.hlts-default-dark .hlts-diff-content {
  white-space: pre;
  padding: 0 10px;
  vertical-align: top;
}
.hlts-default-dark .hlts-diff-row.hlts-diff-context {
  background: transparent;
}
.hlts-default-dark .hlts-diff-row.hlts-diff-added {
  background: rgba(46, 160, 67, 0.18);
}
.hlts-default-dark .hlts-diff-row.hlts-diff-removed {
  background: rgba(248, 81, 73, 0.18);
}
.hlts-default-dark .hlts-diff-row.hlts-diff-modified {
  background: rgba(210, 153, 34, 0.2);
}
.hlts-default-dark .hlts-diff-sign {
  width: 24px;
  text-align: center;
  color: #9da5b4;
  user-select: none;
  -webkit-user-select: none;
}

/* tree-sitter-ts-highlight - GitHub Light Theme */

.hlts.hlts-github-light {
  background: #ffffff;
  color: #1f2328;
}

.hlts-github-light .hlts-keyword {
  color: #cf222e;
  font-weight: bold;
}

.hlts-github-light .hlts-identifier {
  color: #1f2328;
}

.hlts-github-light .hlts-string {
  color: #0a3069;
}

.hlts-github-light .hlts-number {
  color: #0550ae;
}

.hlts-github-light .hlts-comment {
  color: #6e7781;
  font-style: italic;
}

.hlts-github-light .hlts-operator {
  color: #1f2328;
}

.hlts-github-light .hlts-punctuation {
  color: #1f2328;
}

.hlts-github-light .hlts-type {
  color: #953800;
}

.hlts-github-light .hlts-decorator {
  color: #8250df;
}

.hlts-github-light .hlts-tag {
  color: #116329;
}

.hlts-github-light .hlts-attribute {
  color: #0550ae;
}

.hlts-github-light .hlts-meta {
  color: #6e7781;
}

.hlts-github-light .hlts-regexp {
  color: #0a3069;
}

.hlts-github-light .hlts-escape {
  color: #0550ae;
  font-weight: bold;
}

.hlts-github-light .hlts-variable {
  color: #953800;
}

.hlts-github-light .hlts-constant {
  color: #0550ae;
}

.hlts-github-light .hlts-error {
  color: #cf222e;
  text-decoration: wavy underline;
}

.hlts-github-light .hlts-plain {
  color: #1f2328;
}

.hlts-github-light .hlts-line-number {
  color: #8c959f;
  border-right: 1px solid #d1d9e0;
  user-select: none;
  -webkit-user-select: none;
}

.hlts-github-light .hlts-table tr:hover {
  background: rgba(0, 0, 0, 0.03);
}

/* Diff views */
.hlts-github-light .hlts-diff {
  border-collapse: collapse;
  width: 100%;
  table-layout: auto;
}

.hlts-github-light .hlts-diff-header .hlts-diff-label {
  text-align: left;
  font-weight: 600;
  padding: 6px 10px;
  border-bottom: 1px solid #d1d9e0;
}

.hlts-github-light .hlts-diff-gutter {
  color: #8c959f;
  text-align: right;
  user-select: none;
  -webkit-user-select: none;
  width: 1%;
  padding: 0 10px;
  vertical-align: top;
  white-space: nowrap;
}

.hlts-github-light .hlts-diff-content {
  white-space: pre;
  padding: 0 10px;
  vertical-align: top;
}

.hlts-github-light .hlts-diff-row.hlts-diff-context {
  background: transparent;
}

.hlts-github-light .hlts-diff-row.hlts-diff-added {
  background: rgba(46, 160, 67, 0.14);
}

.hlts-github-light .hlts-diff-row.hlts-diff-removed {
  background: rgba(207, 34, 46, 0.14);
}

.hlts-github-light .hlts-diff-row.hlts-diff-modified {
  background: rgba(191, 135, 0, 0.14);
}

.hlts-github-light .hlts-diff-sign {
  width: 24px;
  text-align: center;
  color: #57606a;
  user-select: none;
  -webkit-user-select: none;
}

/* tree-sitter-ts-highlight - GitHub Dark Theme */

.hlts.hlts-github-dark {
  background: #0d1117;
  color: #e6edf3;
}

.hlts-github-dark .hlts-keyword {
  color: #ff7b72;
  font-weight: bold;
}

.hlts-github-dark .hlts-identifier {
  color: #e6edf3;
}

.hlts-github-dark .hlts-string {
  color: #a5d6ff;
}

.hlts-github-dark .hlts-number {
  color: #79c0ff;
}

.hlts-github-dark .hlts-comment {
  color: #8b949e;
  font-style: italic;
}

.hlts-github-dark .hlts-operator {
  color: #e6edf3;
}

.hlts-github-dark .hlts-punctuation {
  color: #e6edf3;
}

.hlts-github-dark .hlts-type {
  color: #ffa657;
}

.hlts-github-dark .hlts-decorator {
  color: #d2a8ff;
}

.hlts-github-dark .hlts-tag {
  color: #7ee787;
}

.hlts-github-dark .hlts-attribute {
  color: #79c0ff;
}

.hlts-github-dark .hlts-meta {
  color: #8b949e;
}

.hlts-github-dark .hlts-regexp {
  color: #a5d6ff;
}

.hlts-github-dark .hlts-escape {
  color: #79c0ff;
  font-weight: bold;
}

.hlts-github-dark .hlts-variable {
  color: #ffa657;
}

.hlts-github-dark .hlts-constant {
  color: #79c0ff;
}

.hlts-github-dark .hlts-error {
  color: #ff7b72;
  text-decoration: wavy underline;
}

.hlts-github-dark .hlts-plain {
  color: #e6edf3;
}

.hlts-github-dark .hlts-line-number {
  color: #6e7681;
  border-right: 1px solid #30363d;
  user-select: none;
  -webkit-user-select: none;
}

.hlts-github-dark .hlts-table tr:hover {
  background: rgba(255, 255, 255, 0.03);
}

/* Diff views */
.hlts-github-dark .hlts-diff {
  border-collapse: collapse;
  width: 100%;
  table-layout: auto;
}

.hlts-github-dark .hlts-diff-header .hlts-diff-label {
  text-align: left;
  font-weight: 600;
  padding: 6px 10px;
  border-bottom: 1px solid #30363d;
}

.hlts-github-dark .hlts-diff-gutter {
  color: #6e7681;
  text-align: right;
  user-select: none;
  -webkit-user-select: none;
  width: 1%;
  padding: 0 10px;
  vertical-align: top;
  white-space: nowrap;
}

.hlts-github-dark .hlts-diff-content {
  white-space: pre;
  padding: 0 10px;
  vertical-align: top;
}

.hlts-github-dark .hlts-diff-row.hlts-diff-context {
  background: transparent;
}

.hlts-github-dark .hlts-diff-row.hlts-diff-added {
  background: rgba(46, 160, 67, 0.2);
}

.hlts-github-dark .hlts-diff-row.hlts-diff-removed {
  background: rgba(248, 81, 73, 0.2);
}

.hlts-github-dark .hlts-diff-row.hlts-diff-modified {
  background: rgba(210, 153, 34, 0.22);
}

.hlts-github-dark .hlts-diff-sign {
  width: 24px;
  text-align: center;
  color: #8b949e;
  user-select: none;
  -webkit-user-select: none;
}

/* tree-sitter-ts-highlight - Monokai Theme */

.hlts.hlts-monokai {
  background: #272822;
  color: #f8f8f2;
}

.hlts-monokai .hlts-keyword {
  color: #f92672;
  font-weight: bold;
}

.hlts-monokai .hlts-identifier {
  color: #f8f8f2;
}

.hlts-monokai .hlts-string {
  color: #e6db74;
}

.hlts-monokai .hlts-number {
  color: #ae81ff;
}

.hlts-monokai .hlts-comment {
  color: #75715e;
  font-style: italic;
}

.hlts-monokai .hlts-operator {
  color: #f92672;
}

.hlts-monokai .hlts-punctuation {
  color: #f8f8f2;
}

.hlts-monokai .hlts-type {
  color: #66d9ef;
  font-style: italic;
}

.hlts-monokai .hlts-decorator {
  color: #66d9ef;
}

.hlts-monokai .hlts-tag {
  color: #f92672;
}

.hlts-monokai .hlts-attribute {
  color: #a6e22e;
}

.hlts-monokai .hlts-meta {
  color: #75715e;
}

.hlts-monokai .hlts-regexp {
  color: #e6db74;
}

.hlts-monokai .hlts-escape {
  color: #ae81ff;
  font-weight: bold;
}

.hlts-monokai .hlts-variable {
  color: #fd971f;
}

.hlts-monokai .hlts-constant {
  color: #ae81ff;
}

.hlts-monokai .hlts-error {
  color: #f92672;
  text-decoration: wavy underline;
}

.hlts-monokai .hlts-plain {
  color: #f8f8f2;
}

.hlts-monokai .hlts-line-number {
  color: #90908a;
  border-right: 1px solid #3e3d32;
  user-select: none;
  -webkit-user-select: none;
}

.hlts-monokai .hlts-table tr:hover {
  background: rgba(255, 255, 255, 0.03);
}

/* Diff views */
.hlts-monokai .hlts-diff {
  border-collapse: collapse;
  width: 100%;
  table-layout: auto;
}

.hlts-monokai .hlts-diff-header .hlts-diff-label {
  text-align: left;
  font-weight: 600;
  padding: 6px 10px;
  border-bottom: 1px solid #3e3d32;
}

.hlts-monokai .hlts-diff-gutter {
  color: #90908a;
  text-align: right;
  user-select: none;
  -webkit-user-select: none;
  width: 1%;
  padding: 0 10px;
  vertical-align: top;
  white-space: nowrap;
}

.hlts-monokai .hlts-diff-content {
  white-space: pre;
  padding: 0 10px;
  vertical-align: top;
}

.hlts-monokai .hlts-diff-row.hlts-diff-context {
  background: transparent;
}

.hlts-monokai .hlts-diff-row.hlts-diff-added {
  background: rgba(166, 226, 46, 0.18);
}

.hlts-monokai .hlts-diff-row.hlts-diff-removed {
  background: rgba(249, 38, 114, 0.2);
}

.hlts-monokai .hlts-diff-row.hlts-diff-modified {
  background: rgba(253, 151, 31, 0.2);
}

.hlts-monokai .hlts-diff-sign {
  width: 24px;
  text-align: center;
  color: #ae81ff;
  user-select: none;
  -webkit-user-select: none;
}

/* tree-sitter-ts-highlight - Dracula Theme */

.hlts.hlts-dracula {
  background: #282a36;
  color: #f8f8f2;
}

.hlts-dracula .hlts-keyword {
  color: #ff79c6;
  font-weight: bold;
}

.hlts-dracula .hlts-identifier {
  color: #f8f8f2;
}

.hlts-dracula .hlts-string {
  color: #f1fa8c;
}

.hlts-dracula .hlts-number {
  color: #bd93f9;
}

.hlts-dracula .hlts-comment {
  color: #6272a4;
  font-style: italic;
}

.hlts-dracula .hlts-operator {
  color: #ff79c6;
}

.hlts-dracula .hlts-punctuation {
  color: #f8f8f2;
}

.hlts-dracula .hlts-type {
  color: #8be9fd;
  font-style: italic;
}

.hlts-dracula .hlts-decorator {
  color: #50fa7b;
}

.hlts-dracula .hlts-tag {
  color: #ff79c6;
}

.hlts-dracula .hlts-attribute {
  color: #50fa7b;
}

.hlts-dracula .hlts-meta {
  color: #6272a4;
}

.hlts-dracula .hlts-regexp {
  color: #f1fa8c;
}

.hlts-dracula .hlts-escape {
  color: #bd93f9;
  font-weight: bold;
}

.hlts-dracula .hlts-variable {
  color: #ffb86c;
}

.hlts-dracula .hlts-constant {
  color: #bd93f9;
}

.hlts-dracula .hlts-error {
  color: #ff5555;
  text-decoration: wavy underline;
}

.hlts-dracula .hlts-plain {
  color: #f8f8f2;
}

.hlts-dracula .hlts-line-number {
  color: #6272a4;
  border-right: 1px solid #44475a;
  user-select: none;
  -webkit-user-select: none;
}

.hlts-dracula .hlts-table tr:hover {
  background: rgba(255, 255, 255, 0.03);
}

/* Diff views */
.hlts-dracula .hlts-diff {
  border-collapse: collapse;
  width: 100%;
  table-layout: auto;
}

.hlts-dracula .hlts-diff-header .hlts-diff-label {
  text-align: left;
  font-weight: 600;
  padding: 6px 10px;
  border-bottom: 1px solid #44475a;
}

.hlts-dracula .hlts-diff-gutter {
  color: #6272a4;
  text-align: right;
  user-select: none;
  -webkit-user-select: none;
  width: 1%;
  padding: 0 10px;
  vertical-align: top;
  white-space: nowrap;
}

.hlts-dracula .hlts-diff-content {
  white-space: pre;
  padding: 0 10px;
  vertical-align: top;
}

.hlts-dracula .hlts-diff-row.hlts-diff-context {
  background: transparent;
}

.hlts-dracula .hlts-diff-row.hlts-diff-added {
  background: rgba(80, 250, 123, 0.15);
}

.hlts-dracula .hlts-diff-row.hlts-diff-removed {
  background: rgba(255, 85, 85, 0.18);
}

.hlts-dracula .hlts-diff-row.hlts-diff-modified {
  background: rgba(255, 184, 108, 0.18);
}

.hlts-dracula .hlts-diff-sign {
  width: 24px;
  text-align: center;
  color: #bd93f9;
  user-select: none;
  -webkit-user-select: none;
}

/* tree-sitter-ts-highlight - Nord Theme */

.hlts.hlts-nord {
  background: #2e3440;
  color: #d8dee9;
}

.hlts-nord .hlts-keyword {
  color: #81a1c1;
  font-weight: bold;
}

.hlts-nord .hlts-identifier {
  color: #d8dee9;
}

.hlts-nord .hlts-string {
  color: #a3be8c;
}

.hlts-nord .hlts-number {
  color: #b48ead;
}

.hlts-nord .hlts-comment {
  color: #616e88;
  font-style: italic;
}

.hlts-nord .hlts-operator {
  color: #81a1c1;
}

.hlts-nord .hlts-punctuation {
  color: #eceff4;
}

.hlts-nord .hlts-type {
  color: #8fbcbb;
}

.hlts-nord .hlts-decorator {
  color: #d08770;
}

.hlts-nord .hlts-tag {
  color: #81a1c1;
}

.hlts-nord .hlts-attribute {
  color: #8fbcbb;
}

.hlts-nord .hlts-meta {
  color: #616e88;
}

.hlts-nord .hlts-regexp {
  color: #ebcb8b;
}

.hlts-nord .hlts-escape {
  color: #d08770;
  font-weight: bold;
}

.hlts-nord .hlts-variable {
  color: #d8dee9;
}

.hlts-nord .hlts-constant {
  color: #b48ead;
}

.hlts-nord .hlts-error {
  color: #bf616a;
  text-decoration: wavy underline;
}

.hlts-nord .hlts-plain {
  color: #d8dee9;
}

.hlts-nord .hlts-line-number {
  color: #4c566a;
  border-right: 1px solid #3b4252;
  user-select: none;
  -webkit-user-select: none;
}

.hlts-nord .hlts-table tr:hover {
  background: rgba(255, 255, 255, 0.03);
}

/* Diff views */
.hlts-nord .hlts-diff {
  border-collapse: collapse;
  width: 100%;
  table-layout: auto;
}

.hlts-nord .hlts-diff-header .hlts-diff-label {
  text-align: left;
  font-weight: 600;
  padding: 6px 10px;
  border-bottom: 1px solid #3b4252;
}

.hlts-nord .hlts-diff-gutter {
  color: #4c566a;
  text-align: right;
  user-select: none;
  -webkit-user-select: none;
  width: 1%;
  padding: 0 10px;
  vertical-align: top;
  white-space: nowrap;
}

.hlts-nord .hlts-diff-content {
  white-space: pre;
  padding: 0 10px;
  vertical-align: top;
}

.hlts-nord .hlts-diff-row.hlts-diff-context {
  background: transparent;
}

.hlts-nord .hlts-diff-row.hlts-diff-added {
  background: rgba(163, 190, 140, 0.18);
}

.hlts-nord .hlts-diff-row.hlts-diff-removed {
  background: rgba(191, 97, 106, 0.2);
}

.hlts-nord .hlts-diff-row.hlts-diff-modified {
  background: rgba(235, 203, 139, 0.2);
}

.hlts-nord .hlts-diff-sign {
  width: 24px;
  text-align: center;
  color: #81a1c1;
  user-select: none;
  -webkit-user-select: none;
}

/* tree-sitter-ts-highlight - Solarized Light Theme */

.hlts.hlts-solarized-light {
  background: #fdf6e3;
  color: #657b83;
}

.hlts-solarized-light .hlts-keyword {
  color: #859900;
  font-weight: bold;
}

.hlts-solarized-light .hlts-identifier {
  color: #657b83;
}

.hlts-solarized-light .hlts-string {
  color: #2aa198;
}

.hlts-solarized-light .hlts-number {
  color: #d33682;
}

.hlts-solarized-light .hlts-comment {
  color: #93a1a1;
  font-style: italic;
}

.hlts-solarized-light .hlts-operator {
  color: #657b83;
}

.hlts-solarized-light .hlts-punctuation {
  color: #657b83;
}

.hlts-solarized-light .hlts-type {
  color: #b58900;
}

.hlts-solarized-light .hlts-decorator {
  color: #6c71c4;
}

.hlts-solarized-light .hlts-tag {
  color: #268bd2;
}

.hlts-solarized-light .hlts-attribute {
  color: #b58900;
}

.hlts-solarized-light .hlts-meta {
  color: #93a1a1;
}

.hlts-solarized-light .hlts-regexp {
  color: #dc322f;
}

.hlts-solarized-light .hlts-escape {
  color: #cb4b16;
  font-weight: bold;
}

.hlts-solarized-light .hlts-variable {
  color: #268bd2;
}

.hlts-solarized-light .hlts-constant {
  color: #d33682;
}

.hlts-solarized-light .hlts-error {
  color: #dc322f;
  text-decoration: wavy underline;
}

.hlts-solarized-light .hlts-plain {
  color: #657b83;
}

.hlts-solarized-light .hlts-line-number {
  color: #93a1a1;
  border-right: 1px solid #eee8d5;
  user-select: none;
  -webkit-user-select: none;
}

.hlts-solarized-light .hlts-table tr:hover {
  background: rgba(0, 0, 0, 0.03);
}

/* Diff views */
.hlts-solarized-light .hlts-diff {
  border-collapse: collapse;
  width: 100%;
  table-layout: auto;
}

.hlts-solarized-light .hlts-diff-header .hlts-diff-label {
  text-align: left;
  font-weight: 600;
  padding: 6px 10px;
  border-bottom: 1px solid #eee8d5;
}

.hlts-solarized-light .hlts-diff-gutter {
  color: #93a1a1;
  text-align: right;
  user-select: none;
  -webkit-user-select: none;
  width: 1%;
  padding: 0 10px;
  vertical-align: top;
  white-space: nowrap;
}

.hlts-solarized-light .hlts-diff-content {
  white-space: pre;
  padding: 0 10px;
  vertical-align: top;
}

.hlts-solarized-light .hlts-diff-row.hlts-diff-context {
  background: transparent;
}

.hlts-solarized-light .hlts-diff-row.hlts-diff-added {
  background: rgba(133, 153, 0, 0.16);
}

.hlts-solarized-light .hlts-diff-row.hlts-diff-removed {
  background: rgba(220, 50, 47, 0.16);
}

.hlts-solarized-light .hlts-diff-row.hlts-diff-modified {
  background: rgba(181, 137, 0, 0.16);
}

.hlts-solarized-light .hlts-diff-sign {
  width: 24px;
  text-align: center;
  color: #586e75;
  user-select: none;
  -webkit-user-select: none;
}

/* tree-sitter-ts-highlight - Solarized Dark Theme */

.hlts.hlts-solarized-dark {
  background: #002b36;
  color: #839496;
}

.hlts-solarized-dark .hlts-keyword {
  color: #859900;
  font-weight: bold;
}

.hlts-solarized-dark .hlts-identifier {
  color: #839496;
}

.hlts-solarized-dark .hlts-string {
  color: #2aa198;
}

.hlts-solarized-dark .hlts-number {
  color: #d33682;
}

.hlts-solarized-dark .hlts-comment {
  color: #586e75;
  font-style: italic;
}

.hlts-solarized-dark .hlts-operator {
  color: #839496;
}

.hlts-solarized-dark .hlts-punctuation {
  color: #839496;
}

.hlts-solarized-dark .hlts-type {
  color: #b58900;
}

.hlts-solarized-dark .hlts-decorator {
  color: #6c71c4;
}

.hlts-solarized-dark .hlts-tag {
  color: #268bd2;
}

.hlts-solarized-dark .hlts-attribute {
  color: #b58900;
}

.hlts-solarized-dark .hlts-meta {
  color: #586e75;
}

.hlts-solarized-dark .hlts-regexp {
  color: #dc322f;
}

.hlts-solarized-dark .hlts-escape {
  color: #cb4b16;
  font-weight: bold;
}

.hlts-solarized-dark .hlts-variable {
  color: #268bd2;
}

.hlts-solarized-dark .hlts-constant {
  color: #d33682;
}

.hlts-solarized-dark .hlts-error {
  color: #dc322f;
  text-decoration: wavy underline;
}

.hlts-solarized-dark .hlts-plain {
  color: #839496;
}

.hlts-solarized-dark .hlts-line-number {
  color: #586e75;
  border-right: 1px solid #073642;
  user-select: none;
  -webkit-user-select: none;
}

.hlts-solarized-dark .hlts-table tr:hover {
  background: rgba(255, 255, 255, 0.03);
}

/* Diff views */
.hlts-solarized-dark .hlts-diff {
  border-collapse: collapse;
  width: 100%;
  table-layout: auto;
}

.hlts-solarized-dark .hlts-diff-header .hlts-diff-label {
  text-align: left;
  font-weight: 600;
  padding: 6px 10px;
  border-bottom: 1px solid #073642;
}

.hlts-solarized-dark .hlts-diff-gutter {
  color: #586e75;
  text-align: right;
  user-select: none;
  -webkit-user-select: none;
  width: 1%;
  padding: 0 10px;
  vertical-align: top;
  white-space: nowrap;
}

.hlts-solarized-dark .hlts-diff-content {
  white-space: pre;
  padding: 0 10px;
  vertical-align: top;
}

.hlts-solarized-dark .hlts-diff-row.hlts-diff-context {
  background: transparent;
}

.hlts-solarized-dark .hlts-diff-row.hlts-diff-added {
  background: rgba(133, 153, 0, 0.2);
}

.hlts-solarized-dark .hlts-diff-row.hlts-diff-removed {
  background: rgba(220, 50, 47, 0.2);
}

.hlts-solarized-dark .hlts-diff-row.hlts-diff-modified {
  background: rgba(181, 137, 0, 0.22);
}

.hlts-solarized-dark .hlts-diff-sign {
  width: 24px;
  text-align: center;
  color: #93a1a1;
  user-select: none;
  -webkit-user-select: none;
}

/* tree-sitter-ts-highlight - Tokyo Night Theme */

.hlts.hlts-tokyo-night {
  background: #1a1b26;
  color: #a9b1d6;
}

.hlts-tokyo-night .hlts-keyword {
  color: #9d7cd8;
  font-weight: bold;
}

.hlts-tokyo-night .hlts-identifier {
  color: #c0caf5;
}

.hlts-tokyo-night .hlts-string {
  color: #9ece6a;
}

.hlts-tokyo-night .hlts-number {
  color: #ff9e64;
}

.hlts-tokyo-night .hlts-comment {
  color: #565f89;
  font-style: italic;
}

.hlts-tokyo-night .hlts-operator {
  color: #89ddff;
}

.hlts-tokyo-night .hlts-punctuation {
  color: #a9b1d6;
}

.hlts-tokyo-night .hlts-type {
  color: #2ac3de;
}

.hlts-tokyo-night .hlts-decorator {
  color: #bb9af7;
}

.hlts-tokyo-night .hlts-tag {
  color: #f7768e;
}

.hlts-tokyo-night .hlts-attribute {
  color: #73daca;
}

.hlts-tokyo-night .hlts-meta {
  color: #565f89;
}

.hlts-tokyo-night .hlts-regexp {
  color: #b4f9f8;
}

.hlts-tokyo-night .hlts-escape {
  color: #ff9e64;
  font-weight: bold;
}

.hlts-tokyo-night .hlts-variable {
  color: #7dcfff;
}

.hlts-tokyo-night .hlts-constant {
  color: #ff9e64;
}

.hlts-tokyo-night .hlts-error {
  color: #f7768e;
  text-decoration: wavy underline;
}

.hlts-tokyo-night .hlts-plain {
  color: #a9b1d6;
}

.hlts-tokyo-night .hlts-line-number {
  color: #3b4261;
  border-right: 1px solid #292e42;
  user-select: none;
  -webkit-user-select: none;
}

.hlts-tokyo-night .hlts-table tr:hover {
  background: rgba(255, 255, 255, 0.03);
}

/* Diff views */
.hlts-tokyo-night .hlts-diff {
  border-collapse: collapse;
  width: 100%;
  table-layout: auto;
}

.hlts-tokyo-night .hlts-diff-header .hlts-diff-label {
  text-align: left;
  font-weight: 600;
  padding: 6px 10px;
  border-bottom: 1px solid #292e42;
}

.hlts-tokyo-night .hlts-diff-gutter {
  color: #3b4261;
  text-align: right;
  user-select: none;
  -webkit-user-select: none;
  width: 1%;
  padding: 0 10px;
  vertical-align: top;
  white-space: nowrap;
}

.hlts-tokyo-night .hlts-diff-content {
  white-space: pre;
  padding: 0 10px;
  vertical-align: top;
}

.hlts-tokyo-night .hlts-diff-row.hlts-diff-context {
  background: transparent;
}

.hlts-tokyo-night .hlts-diff-row.hlts-diff-added {
  background: rgba(158, 206, 106, 0.2);
}

.hlts-tokyo-night .hlts-diff-row.hlts-diff-removed {
  background: rgba(247, 118, 142, 0.2);
}

.hlts-tokyo-night .hlts-diff-row.hlts-diff-modified {
  background: rgba(255, 158, 100, 0.22);
}

.hlts-tokyo-night .hlts-diff-sign {
  width: 24px;
  text-align: center;
  color: #7aa2f7;
  user-select: none;
  -webkit-user-select: none;
}

/* tree-sitter-ts-highlight - Catppuccin Mocha Theme */

.hlts.hlts-catppuccin-mocha {
  background: #1e1e2e;
  color: #cdd6f4;
}

.hlts-catppuccin-mocha .hlts-keyword {
  color: #cba6f7;
  font-weight: bold;
}

.hlts-catppuccin-mocha .hlts-identifier {
  color: #cdd6f4;
}

.hlts-catppuccin-mocha .hlts-string {
  color: #a6e3a1;
}

.hlts-catppuccin-mocha .hlts-number {
  color: #fab387;
}

.hlts-catppuccin-mocha .hlts-comment {
  color: #6c7086;
  font-style: italic;
}

.hlts-catppuccin-mocha .hlts-operator {
  color: #89dceb;
}

.hlts-catppuccin-mocha .hlts-punctuation {
  color: #9399b2;
}

.hlts-catppuccin-mocha .hlts-type {
  color: #f9e2af;
}

.hlts-catppuccin-mocha .hlts-decorator {
  color: #f5c2e7;
}

.hlts-catppuccin-mocha .hlts-tag {
  color: #89b4fa;
}

.hlts-catppuccin-mocha .hlts-attribute {
  color: #f2cdcd;
}

.hlts-catppuccin-mocha .hlts-meta {
  color: #6c7086;
}

.hlts-catppuccin-mocha .hlts-regexp {
  color: #f5c2e7;
}

.hlts-catppuccin-mocha .hlts-escape {
  color: #fab387;
  font-weight: bold;
}

.hlts-catppuccin-mocha .hlts-variable {
  color: #f38ba8;
}

.hlts-catppuccin-mocha .hlts-constant {
  color: #fab387;
}

.hlts-catppuccin-mocha .hlts-error {
  color: #f38ba8;
  text-decoration: wavy underline;
}

.hlts-catppuccin-mocha .hlts-plain {
  color: #cdd6f4;
}

.hlts-catppuccin-mocha .hlts-line-number {
  color: #585b70;
  border-right: 1px solid #313244;
  user-select: none;
  -webkit-user-select: none;
}

.hlts-catppuccin-mocha .hlts-table tr:hover {
  background: rgba(255, 255, 255, 0.03);
}

/* Diff views */
.hlts-catppuccin-mocha .hlts-diff {
  border-collapse: collapse;
  width: 100%;
  table-layout: auto;
}

.hlts-catppuccin-mocha .hlts-diff-header .hlts-diff-label {
  text-align: left;
  font-weight: 600;
  padding: 6px 10px;
  border-bottom: 1px solid #313244;
}

.hlts-catppuccin-mocha .hlts-diff-gutter {
  color: #585b70;
  text-align: right;
  user-select: none;
  -webkit-user-select: none;
  width: 1%;
  padding: 0 10px;
  vertical-align: top;
  white-space: nowrap;
}

.hlts-catppuccin-mocha .hlts-diff-content {
  white-space: pre;
  padding: 0 10px;
  vertical-align: top;
}

.hlts-catppuccin-mocha .hlts-diff-row.hlts-diff-context {
  background: transparent;
}

.hlts-catppuccin-mocha .hlts-diff-row.hlts-diff-added {
  background: rgba(166, 227, 161, 0.2);
}

.hlts-catppuccin-mocha .hlts-diff-row.hlts-diff-removed {
  background: rgba(243, 139, 168, 0.22);
}

.hlts-catppuccin-mocha .hlts-diff-row.hlts-diff-modified {
  background: rgba(250, 179, 135, 0.22);
}

.hlts-catppuccin-mocha .hlts-diff-sign {
  width: 24px;
  text-align: center;
  color: #89b4fa;
  user-select: none;
  -webkit-user-select: none;
}
  </style>
  <script>
window.__TS_DEMO_BUNDLE_OK__ = false;
window.__TS_DEMO_BUNDLE_ERROR__ = null;
try {
"use strict";
var TreeSitterTSHighlightDemo = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

  // demos/browser-entry.ts
  var browser_entry_exports = {};
  __export(browser_entry_exports, {
    demoApi: () => demoApi
  });

  // ../tree-sitter-ts/dist/index.js
  var CharReader = class {
    constructor(source) {
      __publicField(this, "src");
      __publicField(this, "len");
      __publicField(this, "pos", 0);
      __publicField(this, "line", 1);
      __publicField(this, "col", 0);
      this.src = source;
      this.len = source.length;
    }
    /** Current byte offset */
    get offset() {
      return this.pos;
    }
    /** Whether we've reached end of source */
    get eof() {
      return this.pos >= this.len;
    }
    /** Remaining characters from current position */
    get remaining() {
      return this.len - this.pos;
    }
    /** Current position as Position object */
    get position() {
      return { line: this.line, column: this.col, offset: this.pos };
    }
    /** Peek at the current character without advancing */
    peek() {
      return this.pos < this.len ? this.src[this.pos] : "";
    }
    /** Peek at character at offset from current position */
    peekAt(offset) {
      const idx = this.pos + offset;
      return idx < this.len ? this.src[idx] : "";
    }
    /** Peek at a substring from current position */
    peekString(length) {
      return this.src.slice(this.pos, this.pos + length);
    }
    /** Get the char code at current position */
    peekCode() {
      return this.pos < this.len ? this.src.charCodeAt(this.pos) : -1;
    }
    /** Advance one character and return it */
    advance() {
      if (this.pos >= this.len) return "";
      const ch = this.src[this.pos];
      this.pos++;
      if (ch === "\n") {
        this.line++;
        this.col = 0;
      } else if (ch === "\r") {
        if (this.pos < this.len && this.src[this.pos] === "\n") {
          this.pos++;
        }
        this.line++;
        this.col = 0;
      } else {
        this.col++;
      }
      return ch;
    }
    /** Advance N characters and return the consumed substring */
    advanceN(n) {
      const start = this.pos;
      for (let i = 0; i < n && this.pos < this.len; i++) {
        this.advance();
      }
      return this.src.slice(start, this.pos);
    }
    /** Check if source starts with the given string at current position */
    startsWith(str) {
      if (this.pos + str.length > this.len) return false;
      for (let i = 0; i < str.length; i++) {
        if (this.src[this.pos + i] !== str[i]) return false;
      }
      return true;
    }
    /** Get a slice of the source from start offset to current position */
    sliceFrom(startOffset) {
      return this.src.slice(startOffset, this.pos);
    }
    /** Get the full source string */
    get source() {
      return this.src;
    }
    /** Save current state for backtracking */
    save() {
      return { pos: this.pos, line: this.line, col: this.col };
    }
    /** Restore a previously saved state */
    restore(state) {
      this.pos = state.pos;
      this.line = state.line;
      this.col = state.col;
    }
  };
  var StateMachine = class {
    constructor(initialState) {
      __publicField(this, "stack");
      this.stack = [initialState];
    }
    /** Current state name */
    get current() {
      return this.stack[this.stack.length - 1];
    }
    /** Stack depth */
    get depth() {
      return this.stack.length;
    }
    /** Push a new state onto the stack */
    push(state) {
      this.stack.push(state);
    }
    /** Pop the current state. Never pops the last state. */
    pop() {
      if (this.stack.length > 1) {
        this.stack.pop();
      }
    }
    /** Replace the current state */
    switchTo(state) {
      this.stack[this.stack.length - 1] = state;
    }
    /** Apply transitions from a matched rule */
    applyTransition(rule) {
      if (rule.push) {
        this.push(rule.push);
      } else if (rule.pop) {
        this.pop();
      } else if (rule.switchTo) {
        this.switchTo(rule.switchTo);
      }
    }
    /** Save current stack state for backtracking */
    save() {
      return [...this.stack];
    }
    /** Restore a previously saved stack state */
    restore(saved) {
      this.stack.length = 0;
      this.stack.push(...saved);
    }
  };
  function compileCharClass(def, charClasses = {}) {
    return buildTest(def, charClasses);
  }
  function buildTest(def, refs) {
    if ("predefined" in def) {
      switch (def.predefined) {
        case "letter":
          return (ch) => /^[a-zA-Z\u00C0-\u024F]$/.test(ch);
        case "upper":
          return (ch) => ch >= "A" && ch <= "Z";
        case "lower":
          return (ch) => ch >= "a" && ch <= "z";
        case "digit":
          return (ch) => ch >= "0" && ch <= "9";
        case "hexDigit":
          return (ch) => ch >= "0" && ch <= "9" || ch >= "a" && ch <= "f" || ch >= "A" && ch <= "F";
        case "alphanumeric":
          return (ch) => /^[a-zA-Z\u00C0-\u024F]$/.test(ch) || ch >= "0" && ch <= "9";
        case "whitespace":
          return (ch) => ch === " " || ch === "	";
        case "newline":
          return (ch) => ch === "\n" || ch === "\r";
        case "any":
          return (ch) => ch.length > 0;
      }
    }
    if ("chars" in def) {
      const set = new Set(def.chars);
      return (ch) => set.has(ch);
    }
    if ("range" in def) {
      const [lo, hi] = def.range;
      return (ch) => ch >= lo && ch <= hi;
    }
    if ("union" in def) {
      const tests = def.union.map((c) => buildTest(c, refs));
      return (ch) => tests.some((t) => t(ch));
    }
    if ("negate" in def) {
      const inner = buildTest(def.negate, refs);
      return (ch) => ch.length > 0 && !inner(ch);
    }
    if ("ref" in def) {
      const resolved = refs[def.ref];
      if (!resolved) {
        throw new Error(`Unknown charClass reference: "${def.ref}"`);
      }
      return buildTest(resolved, refs);
    }
    throw new Error(`Unknown CharClass variant: ${JSON.stringify(def)}`);
  }
  function compileMatcher(matcher, charClasses = {}) {
    var _a, _b;
    switch (matcher.kind) {
      case "string":
        return compileStringMatcher(matcher.value);
      case "keywords":
        return compileKeywordsMatcher(matcher.words);
      case "delimited":
        return compileDelimitedMatcher(
          matcher.open,
          matcher.close,
          matcher.escape,
          (_a = matcher.multiline) != null ? _a : false,
          (_b = matcher.nested) != null ? _b : false
        );
      case "line":
        return compileLineMatcher(matcher.start);
      case "charSequence":
        return compileCharSequenceMatcher(
          matcher.first,
          matcher.rest,
          charClasses
        );
      case "number":
        return compileNumberMatcher(matcher);
      case "sequence":
        return compileSequenceMatcher(matcher.elements, charClasses);
      case "pattern":
        return compilePatternMatcher(matcher.regex);
    }
  }
  function compileStringMatcher(value) {
    if (typeof value === "string") {
      const len = value.length;
      return (reader) => reader.startsWith(value) ? len : 0;
    }
    const sorted = [...value].sort((a, b) => b.length - a.length);
    return (reader) => {
      for (const s of sorted) {
        if (reader.startsWith(s)) return s.length;
      }
      return 0;
    };
  }
  function compileKeywordsMatcher(words) {
    const sorted = [...words].sort((a, b) => b.length - a.length);
    return (reader) => {
      for (const word of sorted) {
        if (!reader.startsWith(word)) continue;
        const afterIdx = word.length;
        const after = reader.peekAt(afterIdx);
        if (after === "" || !isWordChar(after)) {
          const beforeIdx = reader.offset - 1;
          if (beforeIdx < 0 || !isWordChar(reader.source[beforeIdx])) {
            return word.length;
          }
        }
      }
      return 0;
    };
  }
  function isWordChar(ch) {
    return /^[a-zA-Z0-9_$]$/.test(ch);
  }
  function compileDelimitedMatcher(open, close, escape, multiline, nested) {
    const openLen = open.length;
    const closeLen = close.length;
    return (reader) => {
      if (!reader.startsWith(open)) return 0;
      const startPos = reader.offset;
      const src = reader.source;
      let pos = startPos + openLen;
      let depth = 1;
      while (pos < src.length) {
        if (escape && src[pos] === escape) {
          pos += 2;
          continue;
        }
        if (nested && matchAt(src, pos, open)) {
          depth++;
          pos += openLen;
          continue;
        }
        if (matchAt(src, pos, close)) {
          depth--;
          if (depth === 0) {
            return pos + closeLen - startPos;
          }
          pos += closeLen;
          continue;
        }
        if (!multiline && (src[pos] === "\n" || src[pos] === "\r")) {
          return 0;
        }
        pos++;
      }
      return 0;
    };
  }
  function matchAt(src, pos, str) {
    for (let i = 0; i < str.length; i++) {
      if (src[pos + i] !== str[i]) return false;
    }
    return true;
  }
  function compileLineMatcher(start) {
    const startLen = start.length;
    return (reader) => {
      if (!reader.startsWith(start)) return 0;
      const src = reader.source;
      let pos = reader.offset + startLen;
      while (pos < src.length && src[pos] !== "\n" && src[pos] !== "\r") {
        pos++;
      }
      return pos - reader.offset;
    };
  }
  function compileCharSequenceMatcher(first, rest, charClasses) {
    const testFirst = compileCharClass(first, charClasses);
    const testRest = rest ? compileCharClass(rest, charClasses) : null;
    return (reader) => {
      const ch = reader.peek();
      if (!ch || !testFirst(ch)) return 0;
      if (!testRest) return 1;
      const src = reader.source;
      let pos = reader.offset + 1;
      while (pos < src.length && testRest(src[pos])) {
        pos++;
      }
      return pos - reader.offset;
    };
  }
  function compileNumberMatcher(opts) {
    return (reader) => {
      const src = reader.source;
      const start = reader.offset;
      let pos = start;
      if (pos < src.length && src[pos] === "0" && pos + 1 < src.length) {
        const next = src[pos + 1];
        if (opts.hex && (next === "x" || next === "X")) {
          pos += 2;
          const hexStart = pos;
          while (pos < src.length && isHexDigit(src[pos])) {
            pos++;
            if (opts.separator && pos < src.length && src[pos] === opts.separator) {
              pos++;
            }
          }
          if (pos === hexStart) return 0;
          return consumeSuffix(src, pos, opts.suffix) - start;
        }
        if (opts.octal && (next === "o" || next === "O")) {
          pos += 2;
          const octStart = pos;
          while (pos < src.length && src[pos] >= "0" && src[pos] <= "7") {
            pos++;
            if (opts.separator && pos < src.length && src[pos] === opts.separator) {
              pos++;
            }
          }
          if (pos === octStart) return 0;
          return consumeSuffix(src, pos, opts.suffix) - start;
        }
        if (opts.binary && (next === "b" || next === "B")) {
          pos += 2;
          const binStart = pos;
          while (pos < src.length && (src[pos] === "0" || src[pos] === "1")) {
            pos++;
            if (opts.separator && pos < src.length && src[pos] === opts.separator) {
              pos++;
            }
          }
          if (pos === binStart) return 0;
          return consumeSuffix(src, pos, opts.suffix) - start;
        }
      }
      if (!opts.integer && !opts.float) return 0;
      const isDigit = pos < src.length && src[pos] >= "0" && src[pos] <= "9";
      const isDotDigit = opts.float && pos < src.length && src[pos] === "." && pos + 1 < src.length && src[pos + 1] >= "0" && src[pos + 1] <= "9";
      if (!isDigit && !isDotDigit) return 0;
      while (pos < src.length && src[pos] >= "0" && src[pos] <= "9") {
        pos++;
        if (opts.separator && pos < src.length && src[pos] === opts.separator) {
          pos++;
        }
      }
      if (opts.float && pos < src.length && src[pos] === ".") {
        const afterDot = pos + 1;
        if (afterDot < src.length && src[afterDot] >= "0" && src[afterDot] <= "9") {
          pos = afterDot;
          while (pos < src.length && src[pos] >= "0" && src[pos] <= "9") {
            pos++;
            if (opts.separator && pos < src.length && src[pos] === opts.separator) {
              pos++;
            }
          }
        }
      }
      if (pos === start) return 0;
      if (opts.scientific && pos < src.length && (src[pos] === "e" || src[pos] === "E")) {
        let ePos = pos + 1;
        if (ePos < src.length && (src[ePos] === "+" || src[ePos] === "-")) {
          ePos++;
        }
        const eDigitStart = ePos;
        while (ePos < src.length && src[ePos] >= "0" && src[ePos] <= "9") {
          ePos++;
        }
        if (ePos > eDigitStart) {
          pos = ePos;
        }
      }
      return consumeSuffix(src, pos, opts.suffix) - start;
    };
  }
  function isHexDigit(ch) {
    return ch >= "0" && ch <= "9" || ch >= "a" && ch <= "f" || ch >= "A" && ch <= "F";
  }
  function consumeSuffix(src, pos, suffixes) {
    if (!suffixes) return pos;
    for (const suf of [...suffixes].sort((a, b) => b.length - a.length)) {
      if (matchAt(src, pos, suf)) {
        return pos + suf.length;
      }
    }
    return pos;
  }
  function compileSequenceMatcher(elements, charClasses) {
    const fns = elements.map((e) => compileMatcher(e, charClasses));
    return (reader) => {
      const saved = reader.save();
      let total = 0;
      for (const fn of fns) {
        const n = fn(reader);
        if (n === 0) {
          reader.restore(saved);
          return 0;
        }
        reader.advanceN(n);
        total += n;
      }
      reader.restore(saved);
      return total;
    };
  }
  function compilePatternMatcher(regex) {
    const re = new RegExp("^(?:" + regex + ")");
    return (reader) => {
      const src = reader.source;
      const sub = src.slice(reader.offset);
      const m = re.exec(sub);
      return m ? m[0].length : 0;
    };
  }
  var CompiledLexer = class {
    constructor(config) {
      __publicField(this, "states");
      __publicField(this, "config");
      var _a;
      this.config = config;
      this.states = /* @__PURE__ */ new Map();
      const charClasses = (_a = config.charClasses) != null ? _a : {};
      for (const [name, state] of Object.entries(config.states)) {
        const compiled = state.rules.map((rule) => ({
          scan: compileMatcher(rule.match, charClasses),
          rule
        }));
        this.states.set(name, compiled);
      }
    }
    /** Tokenize source code into a token stream */
    tokenize(source) {
      var _a;
      const reader = new CharReader(source);
      const sm = new StateMachine(this.config.initialState);
      const tokens = [];
      while (!reader.eof) {
        const currentState = this.states.get(sm.current);
        if (!currentState) {
          throw new Error(`Unknown lexer state: "${sm.current}"`);
        }
        let matched = false;
        const startPos = reader.position;
        for (const { scan, rule } of currentState) {
          const consumed = scan(reader);
          if (consumed > 0) {
            const value = reader.advanceN(consumed);
            const endPos = reader.position;
            const typeDef = this.config.tokenTypes[rule.token];
            tokens.push({
              type: rule.token,
              value,
              category: (_a = typeDef == null ? void 0 : typeDef.category) != null ? _a : "plain",
              range: { start: startPos, end: endPos }
            });
            sm.applyTransition(rule);
            matched = true;
            break;
          }
        }
        if (!matched) {
          const ch = reader.advance();
          const endPos = reader.position;
          tokens.push({
            type: "error",
            value: ch,
            category: "error",
            range: { start: startPos, end: endPos }
          });
        }
      }
      return tokens;
    }
  };
  var lexerCache = /* @__PURE__ */ new WeakMap();
  function getCompiledLexer(config) {
    let lexer = lexerCache.get(config);
    if (!lexer) {
      lexer = new CompiledLexer(config);
      lexerCache.set(config, lexer);
    }
    return lexer;
  }
  function tokenizeWithConfig(source, config) {
    return getCompiledLexer(config).tokenize(source);
  }
  function findBlockSpans(tokens, blockRules) {
    const openToRule = /* @__PURE__ */ new Map();
    const closeToRule = /* @__PURE__ */ new Map();
    for (const rule of blockRules) {
      openToRule.set(rule.open, rule);
      closeToRule.set(rule.close, rule);
    }
    const spans = [];
    const stack = [];
    for (let i = 0; i < tokens.length; i++) {
      const val = tokens[i].value;
      const openRule = openToRule.get(val);
      if (openRule) {
        stack.push({ name: openRule.name, openIndex: i, depth: stack.length });
        continue;
      }
      const closeRule = closeToRule.get(val);
      if (closeRule) {
        for (let j = stack.length - 1; j >= 0; j--) {
          if (stack[j].name === closeRule.name) {
            const entry = stack[j];
            spans.push({
              name: entry.name,
              openIndex: entry.openIndex,
              closeIndex: i,
              depth: entry.depth
            });
            stack.length = j;
            break;
          }
        }
      }
    }
    spans.sort((a, b) => a.openIndex - b.openIndex);
    return spans;
  }
  function findNextBlock(spans, afterIndex, blockName) {
    for (const span of spans) {
      if (span.openIndex >= afterIndex && span.name === blockName) {
        return span;
      }
    }
    return void 0;
  }
  function detectSymbols(tokens, rules, blockSpans, skipTokens) {
    var _a, _b, _c, _d, _e, _f, _g;
    const filtered = [];
    for (let i = 0; i < tokens.length; i++) {
      if (!skipTokens.has(tokens[i].type)) {
        filtered.push({ token: tokens[i], originalIndex: i });
      }
    }
    const symbols = [];
    const used = /* @__PURE__ */ new Set();
    for (const rule of rules) {
      for (let fi = 0; fi < filtered.length; fi++) {
        if (used.has(fi)) continue;
        const match = tryMatch(filtered, fi, rule.pattern);
        if (!match) continue;
        const name = (_a = match.captures["name"]) != null ? _a : rule.name;
        const startToken = filtered[match.startIndex].token;
        const startLine = startToken.range.start.line;
        let endLine = startLine;
        if (rule.hasBody) {
          if (rule.bodyStyle === "braces") {
            const afterOrigIdx = (_c = (_b = filtered[match.endIndex - 1]) == null ? void 0 : _b.originalIndex) != null ? _c : 0;
            const block = findNextBlock(blockSpans, afterOrigIdx, "braces");
            if (block) {
              endLine = tokens[block.closeIndex].range.end.line;
            }
          } else if (rule.bodyStyle === "indentation") {
            const baseIndent = startToken.range.start.column;
            endLine = findIndentationEnd(tokens, (_e = (_d = filtered[match.endIndex - 1]) == null ? void 0 : _d.originalIndex) != null ? _e : 0, baseIndent);
          }
        } else {
          const lastMatchOrigIdx = (_g = (_f = filtered[match.endIndex - 1]) == null ? void 0 : _f.originalIndex) != null ? _g : 0;
          endLine = findStatementEnd(tokens, lastMatchOrigIdx);
        }
        symbols.push({
          name,
          kind: rule.kind,
          startLine,
          endLine
        });
        for (let k = match.startIndex; k < match.endIndex; k++) {
          used.add(k);
        }
      }
    }
    symbols.sort((a, b) => a.startLine - b.startLine);
    return symbols;
  }
  function tryMatch(filtered, startIdx, pattern) {
    var _a;
    const captures = {};
    let idx = startIdx;
    for (let pi = 0; pi < pattern.length; pi++) {
      const step = pattern[pi];
      if (idx >= filtered.length) return null;
      if ("skip" in step && step.skip) {
        const nextStep = pattern[pi + 1];
        if (!nextStep) return null;
        const maxTokens = (_a = step.maxTokens) != null ? _a : 50;
        let found = false;
        const limit = Math.min(idx + maxTokens, filtered.length);
        for (let si = idx; si < limit; si++) {
          if (matchSingleStep(filtered[si].token, nextStep, captures)) {
            idx = si;
            found = true;
            break;
          }
        }
        if (!found) return null;
        idx++;
        pi++;
        continue;
      }
      if ("optional" in step) {
        if (matchSingleStep(filtered[idx].token, step.optional, captures)) {
          idx++;
        }
        continue;
      }
      if ("anyOf" in step) {
        let anyMatched = false;
        for (const alt of step.anyOf) {
          if (matchSingleStep(filtered[idx].token, alt, captures)) {
            anyMatched = true;
            idx++;
            break;
          }
        }
        if (!anyMatched) return null;
        continue;
      }
      if ("token" in step) {
        if (!matchTokenStep(filtered[idx].token, step)) return null;
        if (step.capture) {
          captures[step.capture] = filtered[idx].token.value;
        }
        idx++;
        continue;
      }
      return null;
    }
    return { startIndex: startIdx, endIndex: idx, captures };
  }
  function matchSingleStep(token, step, captures) {
    if ("token" in step) {
      if (!matchTokenStep(token, step)) return false;
      if (step.capture) captures[step.capture] = token.value;
      return true;
    }
    if ("anyOf" in step) {
      return step.anyOf.some((alt) => matchSingleStep(token, alt, captures));
    }
    return false;
  }
  function matchTokenStep(token, step) {
    if (token.type !== step.token) return false;
    if (step.value !== void 0 && token.value !== step.value) return false;
    return true;
  }
  function findIndentationEnd(tokens, afterIndex, baseIndent) {
    var _a, _b;
    let lastContentLine = (_b = (_a = tokens[afterIndex]) == null ? void 0 : _a.range.start.line) != null ? _b : 1;
    let foundBody = false;
    for (let i = afterIndex + 1; i < tokens.length; i++) {
      const tok = tokens[i];
      if (tok.category === "whitespace" || tok.category === "newline") continue;
      const line = tok.range.start.line;
      const col = tok.range.start.column;
      if (!foundBody) {
        if (col > baseIndent) {
          foundBody = true;
          lastContentLine = line;
        } else {
          return lastContentLine;
        }
      } else {
        if (col <= baseIndent) {
          return lastContentLine;
        }
        lastContentLine = line;
      }
    }
    return lastContentLine;
  }
  function findStatementEnd(tokens, fromIndex) {
    var _a, _b;
    let line = (_b = (_a = tokens[fromIndex]) == null ? void 0 : _a.range.end.line) != null ? _b : 1;
    let depth = 0;
    for (let i = fromIndex + 1; i < tokens.length; i++) {
      const tok = tokens[i];
      if (tok.value === "{" || tok.value === "(" || tok.value === "[") depth++;
      if (tok.value === "}" || tok.value === ")" || tok.value === "]") depth--;
      if (depth === 0) {
        if (tok.value === ";") return tok.range.end.line;
        if (tok.category === "newline" && depth <= 0) return line;
      }
      if (tok.category !== "whitespace" && tok.category !== "newline") {
        line = tok.range.end.line;
      }
    }
    return line;
  }
  function extractSymbolsFromProfile(source, profile) {
    if (!profile.structure) return [];
    const tokens = tokenizeWithConfig(source, profile.lexer);
    return extractSymbolsFromTokens(tokens, profile);
  }
  function extractSymbolsFromTokens(tokens, profile) {
    var _a;
    if (!profile.structure) return [];
    const { blocks, symbols: symbolRules } = profile.structure;
    const skipTokens = new Set((_a = profile.lexer.skipTokens) != null ? _a : []);
    const blockSpans = findBlockSpans(tokens, blocks);
    return detectSymbols(tokens, symbolRules, blockSpans, skipTokens);
  }
  var json = {
    name: "json",
    displayName: "JSON",
    version: "1.0.0",
    fileExtensions: [".json"],
    mimeTypes: ["application/json"],
    lexer: {
      tokenTypes: {
        string: { category: "string" },
        number: { category: "number" },
        constant: { category: "constant" },
        punctuation: { category: "punctuation" },
        whitespace: { category: "whitespace" },
        newline: { category: "newline" }
      },
      initialState: "default",
      skipTokens: ["whitespace", "newline"],
      states: {
        default: {
          rules: [
            // Strings
            {
              match: { kind: "delimited", open: '"', close: '"', escape: "\\" },
              token: "string"
            },
            // Numbers
            {
              match: {
                kind: "number",
                integer: true,
                float: true,
                scientific: true
              },
              token: "number"
            },
            // Constants: true, false, null
            {
              match: { kind: "keywords", words: ["true", "false", "null"] },
              token: "constant"
            },
            // Punctuation
            {
              match: {
                kind: "string",
                value: ["{", "}", "[", "]", ":", ","]
              },
              token: "punctuation"
            },
            // Whitespace
            {
              match: {
                kind: "charSequence",
                first: { predefined: "whitespace" },
                rest: { predefined: "whitespace" }
              },
              token: "whitespace"
            },
            {
              match: { kind: "charSequence", first: { predefined: "newline" } },
              token: "newline"
            }
          ]
        }
      }
    },
    structure: {
      blocks: [
        { name: "object", open: "{", close: "}" },
        { name: "array", open: "[", close: "]" }
      ],
      symbols: []
    },
    grammar: {
      entry: "value",
      rules: {
        value: {
          alternatives: [
            [{ rule: "object" }],
            [{ rule: "array" }],
            [{ token: "string" }],
            [{ token: "number" }],
            [{ token: "constant" }]
          ]
        },
        object: {
          alternatives: [
            [
              { token: "punctuation", value: "{" },
              {
                optional: {
                  repeat: [{ rule: "pair" }],
                  min: 1,
                  separator: { token: "punctuation", value: "," }
                }
              },
              { token: "punctuation", value: "}" }
            ]
          ]
        },
        pair: {
          alternatives: [
            [
              { token: "string", field: "key" },
              { token: "punctuation", value: ":" },
              { rule: "value", field: "value" }
            ]
          ]
        },
        array: {
          alternatives: [
            [
              { token: "punctuation", value: "[" },
              {
                optional: {
                  repeat: [{ rule: "value" }],
                  min: 1,
                  separator: { token: "punctuation", value: "," }
                }
              },
              { token: "punctuation", value: "]" }
            ]
          ]
        }
      },
      recovery: [
        { context: "object", syncTokens: ["}", ","] },
        { context: "array", syncTokens: ["]", ","] }
      ]
    }
  };
  var css = {
    name: "css",
    displayName: "CSS",
    version: "1.0.0",
    fileExtensions: [".css"],
    mimeTypes: ["text/css"],
    lexer: {
      charClasses: {
        identStart: {
          union: [{ predefined: "letter" }, { chars: "_-" }]
        },
        identPart: {
          union: [{ predefined: "alphanumeric" }, { chars: "_-" }]
        }
      },
      tokenTypes: {
        comment: { category: "comment" },
        string: { category: "string" },
        number: { category: "number" },
        color: { category: "constant", subcategory: "color" },
        keyword: { category: "keyword" },
        at_rule: { category: "keyword", subcategory: "at-rule" },
        property: { category: "identifier", subcategory: "property" },
        selector: { category: "tag", subcategory: "selector" },
        pseudo: { category: "keyword", subcategory: "pseudo" },
        identifier: { category: "identifier" },
        operator: { category: "operator" },
        punctuation: { category: "punctuation" },
        unit: { category: "keyword", subcategory: "unit" },
        whitespace: { category: "whitespace" },
        newline: { category: "newline" }
      },
      initialState: "default",
      skipTokens: ["whitespace", "newline", "comment"],
      states: {
        default: {
          rules: [
            // Block comments
            {
              match: {
                kind: "delimited",
                open: "/*",
                close: "*/",
                multiline: true
              },
              token: "comment"
            },
            // Strings
            {
              match: { kind: "delimited", open: '"', close: '"', escape: "\\" },
              token: "string"
            },
            {
              match: { kind: "delimited", open: "'", close: "'", escape: "\\" },
              token: "string"
            },
            // At-rules (@media, @keyframes, @import, etc.)
            {
              match: {
                kind: "sequence",
                elements: [
                  { kind: "string", value: "@" },
                  {
                    kind: "charSequence",
                    first: { predefined: "letter" },
                    rest: { ref: "identPart" }
                  }
                ]
              },
              token: "at_rule"
            },
            // Hex colors
            {
              match: {
                kind: "sequence",
                elements: [
                  { kind: "string", value: "#" },
                  {
                    kind: "charSequence",
                    first: { predefined: "hexDigit" },
                    rest: { predefined: "hexDigit" }
                  }
                ]
              },
              token: "color"
            },
            // Numbers with units
            {
              match: {
                kind: "number",
                integer: true,
                float: true,
                suffix: [
                  "px",
                  "em",
                  "rem",
                  "%",
                  "vh",
                  "vw",
                  "vmin",
                  "vmax",
                  "ch",
                  "ex",
                  "cm",
                  "mm",
                  "in",
                  "pt",
                  "pc",
                  "s",
                  "ms",
                  "deg",
                  "rad",
                  "grad",
                  "turn",
                  "fr",
                  "dpi",
                  "dpcm",
                  "dppx"
                ]
              },
              token: "number"
            },
            // Keywords
            {
              match: {
                kind: "keywords",
                words: [
                  "important",
                  "inherit",
                  "initial",
                  "unset",
                  "revert",
                  "none",
                  "auto",
                  "normal",
                  "bold",
                  "italic",
                  "solid",
                  "dashed",
                  "dotted",
                  "block",
                  "inline",
                  "flex",
                  "grid",
                  "absolute",
                  "relative",
                  "fixed",
                  "sticky",
                  "static",
                  "hidden",
                  "visible",
                  "scroll",
                  "transparent"
                ]
              },
              token: "keyword"
            },
            // Pseudo-classes and pseudo-elements
            {
              match: {
                kind: "sequence",
                elements: [
                  { kind: "string", value: "::" },
                  {
                    kind: "charSequence",
                    first: { predefined: "letter" },
                    rest: { ref: "identPart" }
                  }
                ]
              },
              token: "pseudo"
            },
            {
              match: {
                kind: "sequence",
                elements: [
                  { kind: "string", value: ":" },
                  {
                    kind: "charSequence",
                    first: { predefined: "letter" },
                    rest: { ref: "identPart" }
                  }
                ]
              },
              token: "pseudo"
            },
            // Identifiers
            {
              match: {
                kind: "charSequence",
                first: { ref: "identStart" },
                rest: { ref: "identPart" }
              },
              token: "identifier"
            },
            // Operators
            {
              match: {
                kind: "string",
                value: ["+", ">", "~", "*", "=", "^=", "$=", "*=", "|=", "~="]
              },
              token: "operator"
            },
            // Punctuation
            {
              match: {
                kind: "string",
                value: ["{", "}", "(", ")", "[", "]", ";", ":", ",", "."]
              },
              token: "punctuation"
            },
            // !important
            {
              match: { kind: "string", value: "!" },
              token: "operator"
            },
            // Whitespace
            {
              match: {
                kind: "charSequence",
                first: { predefined: "whitespace" },
                rest: { predefined: "whitespace" }
              },
              token: "whitespace"
            },
            {
              match: { kind: "charSequence", first: { predefined: "newline" } },
              token: "newline"
            }
          ]
        }
      }
    },
    structure: {
      blocks: [
        { name: "block", open: "{", close: "}" },
        { name: "parens", open: "(", close: ")" },
        { name: "brackets", open: "[", close: "]" }
      ],
      symbols: [
        {
          name: "at_rule",
          kind: "other",
          pattern: [{ token: "at_rule", capture: "name" }],
          hasBody: true,
          bodyStyle: "braces"
        }
      ],
      folding: [
        { open: { token: "punctuation", value: "{" }, close: { token: "punctuation", value: "}" } }
      ]
    }
  };
  var scss = {
    name: "scss",
    displayName: "SCSS",
    version: "1.0.0",
    fileExtensions: [".scss"],
    mimeTypes: ["text/x-scss"],
    extends: "css",
    lexer: {
      charClasses: {
        identStart: {
          union: [{ predefined: "letter" }, { chars: "_-" }]
        },
        identPart: {
          union: [{ predefined: "alphanumeric" }, { chars: "_-" }]
        }
      },
      tokenTypes: {
        comment: { category: "comment" },
        string: { category: "string" },
        number: { category: "number" },
        color: { category: "constant", subcategory: "color" },
        keyword: { category: "keyword" },
        at_rule: { category: "keyword", subcategory: "at-rule" },
        variable: { category: "variable" },
        interpolation: { category: "punctuation", subcategory: "interpolation" },
        pseudo: { category: "keyword", subcategory: "pseudo" },
        identifier: { category: "identifier" },
        operator: { category: "operator" },
        punctuation: { category: "punctuation" },
        whitespace: { category: "whitespace" },
        newline: { category: "newline" }
      },
      initialState: "default",
      skipTokens: ["whitespace", "newline", "comment"],
      states: {
        default: {
          rules: [
            // Line comments (SCSS-specific)
            { match: { kind: "line", start: "//" }, token: "comment" },
            // Block comments
            {
              match: {
                kind: "delimited",
                open: "/*",
                close: "*/",
                multiline: true
              },
              token: "comment"
            },
            // Strings
            {
              match: { kind: "delimited", open: '"', close: '"', escape: "\\" },
              token: "string"
            },
            {
              match: { kind: "delimited", open: "'", close: "'", escape: "\\" },
              token: "string"
            },
            // Interpolation #{...}
            {
              match: { kind: "string", value: "#{" },
              token: "interpolation",
              push: "interpolation"
            },
            // SCSS variables ($variable)
            {
              match: {
                kind: "sequence",
                elements: [
                  { kind: "string", value: "$" },
                  {
                    kind: "charSequence",
                    first: {
                      union: [{ predefined: "letter" }, { chars: "_" }]
                    },
                    rest: { ref: "identPart" }
                  }
                ]
              },
              token: "variable"
            },
            // At-rules (@mixin, @include, @extend, @import, @use, @forward, etc.)
            {
              match: {
                kind: "sequence",
                elements: [
                  { kind: "string", value: "@" },
                  {
                    kind: "charSequence",
                    first: { predefined: "letter" },
                    rest: { ref: "identPart" }
                  }
                ]
              },
              token: "at_rule"
            },
            // Hex colors
            {
              match: {
                kind: "sequence",
                elements: [
                  { kind: "string", value: "#" },
                  {
                    kind: "charSequence",
                    first: { predefined: "hexDigit" },
                    rest: { predefined: "hexDigit" }
                  }
                ]
              },
              token: "color"
            },
            // Numbers with units
            {
              match: {
                kind: "number",
                integer: true,
                float: true,
                suffix: [
                  "px",
                  "em",
                  "rem",
                  "%",
                  "vh",
                  "vw",
                  "vmin",
                  "vmax",
                  "ch",
                  "ex",
                  "s",
                  "ms",
                  "deg",
                  "rad",
                  "fr"
                ]
              },
              token: "number"
            },
            // Keywords
            {
              match: {
                kind: "keywords",
                words: [
                  "important",
                  "inherit",
                  "initial",
                  "unset",
                  "none",
                  "auto",
                  "true",
                  "false",
                  "null",
                  "and",
                  "or",
                  "not",
                  "from",
                  "through",
                  "to"
                ]
              },
              token: "keyword"
            },
            // Pseudo selectors
            {
              match: {
                kind: "sequence",
                elements: [
                  { kind: "string", value: "::" },
                  {
                    kind: "charSequence",
                    first: { predefined: "letter" },
                    rest: { ref: "identPart" }
                  }
                ]
              },
              token: "pseudo"
            },
            {
              match: {
                kind: "sequence",
                elements: [
                  { kind: "string", value: ":" },
                  {
                    kind: "charSequence",
                    first: { predefined: "letter" },
                    rest: { ref: "identPart" }
                  }
                ]
              },
              token: "pseudo"
            },
            // & (parent selector)
            { match: { kind: "string", value: "&" }, token: "operator" },
            // Identifiers
            {
              match: {
                kind: "charSequence",
                first: { ref: "identStart" },
                rest: { ref: "identPart" }
              },
              token: "identifier"
            },
            // Operators
            {
              match: {
                kind: "string",
                value: ["+", ">", "~", "*", "=", "^=", "$=", "*=", "|=", "~="]
              },
              token: "operator"
            },
            // Punctuation
            {
              match: {
                kind: "string",
                value: ["{", "}", "(", ")", "[", "]", ";", ":", ",", "."]
              },
              token: "punctuation"
            },
            { match: { kind: "string", value: "!" }, token: "operator" },
            // Whitespace
            {
              match: {
                kind: "charSequence",
                first: { predefined: "whitespace" },
                rest: { predefined: "whitespace" }
              },
              token: "whitespace"
            },
            {
              match: { kind: "charSequence", first: { predefined: "newline" } },
              token: "newline"
            }
          ]
        },
        interpolation: {
          rules: [
            {
              match: { kind: "string", value: "}" },
              token: "interpolation",
              pop: true
            }
            // Inside interpolation, use same rules as default
            // (the engine will fall through to default state rules)
          ]
        }
      }
    },
    structure: {
      blocks: [
        { name: "block", open: "{", close: "}" },
        { name: "parens", open: "(", close: ")" }
      ],
      symbols: [
        {
          name: "mixin_declaration",
          kind: "function",
          pattern: [
            { token: "at_rule", value: "@mixin" },
            { token: "identifier", capture: "name" }
          ],
          hasBody: true,
          bodyStyle: "braces"
        },
        {
          name: "function_declaration",
          kind: "function",
          pattern: [
            { token: "at_rule", value: "@function" },
            { token: "identifier", capture: "name" }
          ],
          hasBody: true,
          bodyStyle: "braces"
        },
        {
          name: "at_rule",
          kind: "other",
          pattern: [{ token: "at_rule", capture: "name" }],
          hasBody: true,
          bodyStyle: "braces"
        }
      ],
      folding: [
        { open: { token: "punctuation", value: "{" }, close: { token: "punctuation", value: "}" } }
      ]
    }
  };
  var python = {
    name: "python",
    displayName: "Python",
    version: "1.0.0",
    fileExtensions: [".py", ".pyi", ".pyw"],
    mimeTypes: ["text/x-python"],
    lexer: {
      charClasses: {
        identStart: {
          union: [{ predefined: "letter" }, { chars: "_" }]
        },
        identPart: {
          union: [{ predefined: "alphanumeric" }, { chars: "_" }]
        }
      },
      tokenTypes: {
        keyword: { category: "keyword" },
        constant: { category: "constant" },
        builtin: { category: "keyword", subcategory: "builtin" },
        identifier: { category: "identifier" },
        type_name: { category: "type" },
        decorator: { category: "decorator" },
        string: { category: "string" },
        fstring_start: { category: "string", subcategory: "fstring" },
        fstring_expr: { category: "punctuation", subcategory: "fstring" },
        number: { category: "number" },
        comment: { category: "comment" },
        operator: { category: "operator" },
        punctuation: { category: "punctuation" },
        indent: { category: "whitespace" },
        dedent: { category: "whitespace" },
        whitespace: { category: "whitespace" },
        newline: { category: "newline" }
      },
      initialState: "default",
      skipTokens: ["whitespace", "newline", "comment", "indent", "dedent"],
      indentation: {
        indentToken: "indent",
        dedentToken: "dedent",
        unit: "detect"
      },
      states: {
        default: {
          rules: [
            // Comments
            { match: { kind: "line", start: "#" }, token: "comment" },
            // Triple-quoted strings (must come before single-quoted)
            {
              match: {
                kind: "delimited",
                open: '"""',
                close: '"""',
                multiline: true,
                escape: "\\"
              },
              token: "string"
            },
            {
              match: {
                kind: "delimited",
                open: "'''",
                close: "'''",
                multiline: true,
                escape: "\\"
              },
              token: "string"
            },
            // F-string triple-quoted (consume whole thing for now)
            {
              match: {
                kind: "pattern",
                regex: '[fF]"""[\\s\\S]*?"""'
              },
              token: "string"
            },
            {
              match: {
                kind: "pattern",
                regex: "[fF]'''[\\s\\S]*?'''"
              },
              token: "string"
            },
            // F-string single-quoted
            {
              match: {
                kind: "pattern",
                regex: '[fF]"(?:\\\\.|[^"\\\\\\n])*"'
              },
              token: "string"
            },
            {
              match: {
                kind: "pattern",
                regex: "[fF]'(?:\\\\.|[^'\\\\\\n])*'"
              },
              token: "string"
            },
            // Raw strings
            {
              match: {
                kind: "pattern",
                regex: '[rRbB]{1,2}"(?:\\\\.|[^"\\\\])*"'
              },
              token: "string"
            },
            {
              match: {
                kind: "pattern",
                regex: "[rRbB]{1,2}'(?:\\\\.|[^'\\\\])*'"
              },
              token: "string"
            },
            // Regular strings
            {
              match: { kind: "delimited", open: '"', close: '"', escape: "\\" },
              token: "string"
            },
            {
              match: { kind: "delimited", open: "'", close: "'", escape: "\\" },
              token: "string"
            },
            // Decorators
            {
              match: {
                kind: "sequence",
                elements: [
                  { kind: "string", value: "@" },
                  {
                    kind: "charSequence",
                    first: { ref: "identStart" },
                    rest: {
                      union: [{ predefined: "alphanumeric" }, { chars: "_." }]
                    }
                  }
                ]
              },
              token: "decorator"
            },
            // Numbers
            {
              match: {
                kind: "number",
                integer: true,
                float: true,
                hex: true,
                binary: true,
                octal: true,
                scientific: true,
                separator: "_"
              },
              token: "number"
            },
            // Keywords
            {
              match: {
                kind: "keywords",
                words: [
                  "and",
                  "as",
                  "assert",
                  "async",
                  "await",
                  "break",
                  "class",
                  "continue",
                  "def",
                  "del",
                  "elif",
                  "else",
                  "except",
                  "finally",
                  "for",
                  "from",
                  "global",
                  "if",
                  "import",
                  "in",
                  "is",
                  "lambda",
                  "nonlocal",
                  "not",
                  "or",
                  "pass",
                  "raise",
                  "return",
                  "try",
                  "while",
                  "with",
                  "yield"
                ]
              },
              token: "keyword"
            },
            // Constants
            {
              match: {
                kind: "keywords",
                words: ["True", "False", "None"]
              },
              token: "constant"
            },
            // Built-in functions
            {
              match: {
                kind: "keywords",
                words: [
                  "print",
                  "len",
                  "range",
                  "int",
                  "str",
                  "float",
                  "list",
                  "dict",
                  "set",
                  "tuple",
                  "type",
                  "isinstance",
                  "issubclass",
                  "super",
                  "property",
                  "staticmethod",
                  "classmethod",
                  "enumerate",
                  "zip",
                  "map",
                  "filter",
                  "sorted",
                  "reversed",
                  "abs",
                  "min",
                  "max",
                  "sum",
                  "any",
                  "all",
                  "open",
                  "input",
                  "hasattr",
                  "getattr",
                  "setattr",
                  "delattr",
                  "vars",
                  "dir"
                ]
              },
              token: "builtin"
            },
            // Type-like identifiers (PascalCase)
            {
              match: {
                kind: "charSequence",
                first: { range: ["A", "Z"] },
                rest: { ref: "identPart" }
              },
              token: "type_name"
            },
            // Identifiers
            {
              match: {
                kind: "charSequence",
                first: { ref: "identStart" },
                rest: { ref: "identPart" }
              },
              token: "identifier"
            },
            // Multi-char operators
            {
              match: {
                kind: "string",
                value: [
                  "**=",
                  "//=",
                  "<<=",
                  ">>=",
                  "**",
                  "//",
                  "<<",
                  ">>",
                  "<=",
                  ">=",
                  "==",
                  "!=",
                  "+=",
                  "-=",
                  "*=",
                  "/=",
                  "%=",
                  "&=",
                  "|=",
                  "^=",
                  "->",
                  ":="
                ]
              },
              token: "operator"
            },
            // Single-char operators
            {
              match: {
                kind: "string",
                value: ["+", "-", "*", "/", "%", "=", "<", ">", "&", "|", "^", "~", "@"]
              },
              token: "operator"
            },
            // Punctuation
            {
              match: {
                kind: "string",
                value: ["{", "}", "(", ")", "[", "]", ":", ";", ",", "."]
              },
              token: "punctuation"
            },
            // Whitespace
            {
              match: {
                kind: "charSequence",
                first: { predefined: "whitespace" },
                rest: { predefined: "whitespace" }
              },
              token: "whitespace"
            },
            {
              match: { kind: "charSequence", first: { predefined: "newline" } },
              token: "newline"
            }
          ]
        },
        fstring_single: {
          rules: [
            // Expression hole
            {
              match: { kind: "string", value: "{" },
              token: "fstring_expr",
              push: "default"
            },
            // End of f-string
            {
              match: { kind: "string", value: ['"', "'"] },
              token: "fstring_start",
              pop: true
            }
          ]
        },
        fstring_triple: {
          rules: [
            {
              match: { kind: "string", value: "{" },
              token: "fstring_expr",
              push: "default"
            },
            {
              match: { kind: "string", value: ['"""', "'''"] },
              token: "fstring_start",
              pop: true
            }
          ]
        }
      }
    },
    structure: {
      blocks: [
        { name: "braces", open: "{", close: "}" },
        { name: "parens", open: "(", close: ")" },
        { name: "brackets", open: "[", close: "]" }
      ],
      symbols: [
        {
          name: "function_definition",
          kind: "function",
          pattern: [
            { token: "keyword", value: "def" },
            { token: "identifier", capture: "name" }
          ],
          hasBody: true,
          bodyStyle: "indentation"
        },
        {
          name: "async_function_definition",
          kind: "function",
          pattern: [
            { token: "keyword", value: "async" },
            { token: "keyword", value: "def" },
            { token: "identifier", capture: "name" }
          ],
          hasBody: true,
          bodyStyle: "indentation"
        },
        {
          name: "class_definition",
          kind: "class",
          pattern: [
            { token: "keyword", value: "class" },
            {
              anyOf: [
                { token: "identifier", capture: "name" },
                { token: "type_name", capture: "name" }
              ]
            }
          ],
          hasBody: true,
          bodyStyle: "indentation"
        },
        {
          name: "decorated_definition",
          kind: "other",
          pattern: [{ token: "decorator", capture: "name" }],
          hasBody: false
        },
        {
          name: "import_statement",
          kind: "import",
          pattern: [{ token: "keyword", value: "import" }],
          hasBody: false
        },
        {
          name: "import_from_statement",
          kind: "import",
          pattern: [
            { token: "keyword", value: "from" },
            { skip: true, maxTokens: 10 },
            { token: "keyword", value: "import" }
          ],
          hasBody: false
        },
        {
          name: "assignment",
          kind: "variable",
          pattern: [
            { token: "identifier", capture: "name" },
            { token: "operator", value: "=" }
          ],
          hasBody: false
        }
      ]
    }
  };
  var go = {
    name: "go",
    displayName: "Go",
    version: "1.0.0",
    fileExtensions: [".go"],
    mimeTypes: ["text/x-go"],
    lexer: {
      charClasses: {
        identStart: {
          union: [{ predefined: "letter" }, { chars: "_" }]
        },
        identPart: {
          union: [{ predefined: "alphanumeric" }, { chars: "_" }]
        }
      },
      tokenTypes: {
        keyword: { category: "keyword" },
        constant: { category: "constant" },
        builtin: { category: "keyword", subcategory: "builtin" },
        identifier: { category: "identifier" },
        type_name: { category: "type" },
        type_keyword: { category: "type", subcategory: "builtin" },
        string: { category: "string" },
        rune: { category: "string", subcategory: "rune" },
        number: { category: "number" },
        comment: { category: "comment" },
        operator: { category: "operator" },
        punctuation: { category: "punctuation" },
        whitespace: { category: "whitespace" },
        newline: { category: "newline" }
      },
      initialState: "default",
      skipTokens: ["whitespace", "newline", "comment"],
      states: {
        default: {
          rules: [
            // Block comments
            {
              match: {
                kind: "delimited",
                open: "/*",
                close: "*/",
                multiline: true
              },
              token: "comment"
            },
            // Line comments
            { match: { kind: "line", start: "//" }, token: "comment" },
            // Raw strings (backtick)
            {
              match: {
                kind: "delimited",
                open: "`",
                close: "`",
                multiline: true
              },
              token: "string"
            },
            // Interpreted strings
            {
              match: { kind: "delimited", open: '"', close: '"', escape: "\\" },
              token: "string"
            },
            // Rune literals
            {
              match: { kind: "delimited", open: "'", close: "'", escape: "\\" },
              token: "rune"
            },
            // Numbers
            {
              match: {
                kind: "number",
                integer: true,
                float: true,
                hex: true,
                octal: true,
                binary: true,
                scientific: true,
                separator: "_"
              },
              token: "number"
            },
            // Keywords
            {
              match: {
                kind: "keywords",
                words: [
                  "break",
                  "case",
                  "chan",
                  "const",
                  "continue",
                  "default",
                  "defer",
                  "else",
                  "fallthrough",
                  "for",
                  "func",
                  "go",
                  "goto",
                  "if",
                  "import",
                  "interface",
                  "map",
                  "package",
                  "range",
                  "return",
                  "select",
                  "struct",
                  "switch",
                  "type",
                  "var"
                ]
              },
              token: "keyword"
            },
            // Constants
            {
              match: {
                kind: "keywords",
                words: ["true", "false", "nil", "iota"]
              },
              token: "constant"
            },
            // Built-in functions
            {
              match: {
                kind: "keywords",
                words: [
                  "append",
                  "cap",
                  "clear",
                  "close",
                  "complex",
                  "copy",
                  "delete",
                  "imag",
                  "len",
                  "make",
                  "max",
                  "min",
                  "new",
                  "panic",
                  "print",
                  "println",
                  "real",
                  "recover"
                ]
              },
              token: "builtin"
            },
            // Built-in types
            {
              match: {
                kind: "keywords",
                words: [
                  "bool",
                  "byte",
                  "complex64",
                  "complex128",
                  "error",
                  "float32",
                  "float64",
                  "int",
                  "int8",
                  "int16",
                  "int32",
                  "int64",
                  "rune",
                  "string",
                  "uint",
                  "uint8",
                  "uint16",
                  "uint32",
                  "uint64",
                  "uintptr",
                  "any",
                  "comparable"
                ]
              },
              token: "type_keyword"
            },
            // Type-like identifiers (PascalCase / exported)
            {
              match: {
                kind: "charSequence",
                first: { range: ["A", "Z"] },
                rest: { ref: "identPart" }
              },
              token: "type_name"
            },
            // Identifiers
            {
              match: {
                kind: "charSequence",
                first: { ref: "identStart" },
                rest: { ref: "identPart" }
              },
              token: "identifier"
            },
            // Multi-char operators
            {
              match: {
                kind: "string",
                value: [
                  ":=",
                  "<-",
                  "<<",
                  ">>",
                  "&^",
                  "&&",
                  "||",
                  "<=",
                  ">=",
                  "==",
                  "!=",
                  "+=",
                  "-=",
                  "*=",
                  "/=",
                  "%=",
                  "&=",
                  "|=",
                  "^=",
                  "<<=",
                  ">>=",
                  "&^=",
                  "++",
                  "--",
                  "..."
                ]
              },
              token: "operator"
            },
            // Single-char operators
            {
              match: {
                kind: "string",
                value: ["+", "-", "*", "/", "%", "=", "<", ">", "&", "|", "^", "!", "~"]
              },
              token: "operator"
            },
            // Punctuation
            {
              match: {
                kind: "string",
                value: ["{", "}", "(", ")", "[", "]", ";", ":", ",", "."]
              },
              token: "punctuation"
            },
            // Whitespace
            {
              match: {
                kind: "charSequence",
                first: { predefined: "whitespace" },
                rest: { predefined: "whitespace" }
              },
              token: "whitespace"
            },
            {
              match: { kind: "charSequence", first: { predefined: "newline" } },
              token: "newline"
            }
          ]
        }
      }
    },
    structure: {
      blocks: [
        { name: "braces", open: "{", close: "}" },
        { name: "parens", open: "(", close: ")" },
        { name: "brackets", open: "[", close: "]" }
      ],
      symbols: [
        {
          name: "function_declaration",
          kind: "function",
          pattern: [
            { token: "keyword", value: "func" },
            { token: "identifier", capture: "name" }
          ],
          hasBody: true,
          bodyStyle: "braces"
        },
        {
          name: "method_declaration",
          kind: "method",
          pattern: [
            { token: "keyword", value: "func" },
            { token: "punctuation", value: "(" },
            { skip: true, maxTokens: 10 },
            { token: "punctuation", value: ")" },
            { token: "identifier", capture: "name" }
          ],
          hasBody: true,
          bodyStyle: "braces"
        },
        {
          name: "type_declaration",
          kind: "type",
          pattern: [
            { token: "keyword", value: "type" },
            { token: "type_name", capture: "name" }
          ],
          hasBody: true,
          bodyStyle: "braces"
        },
        {
          name: "interface_declaration",
          kind: "interface",
          pattern: [
            { token: "keyword", value: "type" },
            { token: "type_name", capture: "name" },
            { token: "keyword", value: "interface" }
          ],
          hasBody: true,
          bodyStyle: "braces"
        },
        {
          name: "struct_declaration",
          kind: "class",
          pattern: [
            { token: "keyword", value: "type" },
            { token: "type_name", capture: "name" },
            { token: "keyword", value: "struct" }
          ],
          hasBody: true,
          bodyStyle: "braces"
        },
        {
          name: "import_declaration",
          kind: "import",
          pattern: [{ token: "keyword", value: "import" }],
          hasBody: false
        },
        {
          name: "var_declaration",
          kind: "variable",
          pattern: [
            { token: "keyword", value: "var" },
            { token: "identifier", capture: "name" }
          ],
          hasBody: false
        },
        {
          name: "const_declaration",
          kind: "constant",
          pattern: [
            { token: "keyword", value: "const" },
            {
              anyOf: [
                { token: "identifier", capture: "name" },
                { token: "punctuation", value: "(" }
              ]
            }
          ],
          hasBody: false
        }
      ],
      folding: [
        { open: { token: "punctuation", value: "{" }, close: { token: "punctuation", value: "}" } }
      ]
    }
  };
  var javascript = {
    name: "javascript",
    displayName: "JavaScript",
    version: "1.0.0",
    fileExtensions: [".js", ".mjs", ".cjs", ".jsx"],
    mimeTypes: ["text/javascript", "application/javascript"],
    lexer: {
      charClasses: {
        identStart: {
          union: [{ predefined: "letter" }, { chars: "_$" }]
        },
        identPart: {
          union: [{ predefined: "alphanumeric" }, { chars: "_$" }]
        }
      },
      tokenTypes: {
        keyword: { category: "keyword" },
        constant: { category: "constant" },
        identifier: { category: "identifier" },
        type_name: { category: "type" },
        string: { category: "string" },
        template_start: { category: "string", subcategory: "template" },
        template_content: { category: "string", subcategory: "template" },
        template_expr_open: {
          category: "punctuation",
          subcategory: "template"
        },
        template_end: { category: "string", subcategory: "template" },
        number: { category: "number" },
        comment: { category: "comment" },
        regexp: { category: "regexp" },
        operator: { category: "operator" },
        punctuation: { category: "punctuation" },
        jsx_tag_open: { category: "tag" },
        jsx_tag_close: { category: "tag" },
        jsx_tag_end: { category: "tag" },
        whitespace: { category: "whitespace" },
        newline: { category: "newline" }
      },
      initialState: "default",
      skipTokens: ["whitespace", "newline", "comment"],
      states: {
        default: {
          rules: [
            // Block comments
            {
              match: {
                kind: "delimited",
                open: "/*",
                close: "*/",
                multiline: true
              },
              token: "comment"
            },
            // Line comments
            { match: { kind: "line", start: "//" }, token: "comment" },
            // Template strings
            {
              match: { kind: "string", value: "`" },
              token: "template_start",
              push: "template_string"
            },
            // Strings
            {
              match: { kind: "delimited", open: '"', close: '"', escape: "\\" },
              token: "string"
            },
            {
              match: { kind: "delimited", open: "'", close: "'", escape: "\\" },
              token: "string"
            },
            // Numbers
            {
              match: {
                kind: "number",
                integer: true,
                float: true,
                hex: true,
                binary: true,
                octal: true,
                scientific: true,
                separator: "_"
              },
              token: "number"
            },
            // Keywords
            {
              match: {
                kind: "keywords",
                words: [
                  "break",
                  "case",
                  "catch",
                  "class",
                  "const",
                  "continue",
                  "debugger",
                  "default",
                  "delete",
                  "do",
                  "else",
                  "export",
                  "extends",
                  "finally",
                  "for",
                  "function",
                  "if",
                  "import",
                  "in",
                  "instanceof",
                  "let",
                  "new",
                  "return",
                  "super",
                  "switch",
                  "this",
                  "throw",
                  "try",
                  "typeof",
                  "var",
                  "void",
                  "while",
                  "with",
                  "yield",
                  "async",
                  "await",
                  "of",
                  "static",
                  "get",
                  "set",
                  "from",
                  "as"
                ]
              },
              token: "keyword"
            },
            // Constants
            {
              match: {
                kind: "keywords",
                words: ["true", "false", "null", "undefined", "NaN", "Infinity"]
              },
              token: "constant"
            },
            // Type-like identifiers (PascalCase)
            {
              match: {
                kind: "charSequence",
                first: { range: ["A", "Z"] },
                rest: { ref: "identPart" }
              },
              token: "type_name"
            },
            // Identifiers
            {
              match: {
                kind: "charSequence",
                first: { ref: "identStart" },
                rest: { ref: "identPart" }
              },
              token: "identifier"
            },
            // Multi-char operators (longest match first)
            {
              match: {
                kind: "string",
                value: [
                  ">>>=",
                  "<<=",
                  ">>=",
                  "**=",
                  "&&=",
                  "||=",
                  "??=",
                  "===",
                  "!==",
                  ">>>",
                  "...",
                  "==",
                  "!=",
                  ">=",
                  "<=",
                  "&&",
                  "||",
                  "??",
                  "?.",
                  "**",
                  "++",
                  "--",
                  "+=",
                  "-=",
                  "*=",
                  "/=",
                  "%=",
                  "&=",
                  "|=",
                  "^=",
                  "=>",
                  "<<",
                  ">>"
                ]
              },
              token: "operator"
            },
            // Single-char operators
            {
              match: {
                kind: "string",
                value: [
                  "+",
                  "-",
                  "*",
                  "/",
                  "%",
                  "=",
                  "!",
                  "<",
                  ">",
                  "&",
                  "|",
                  "^",
                  "~",
                  "?",
                  ":"
                ]
              },
              token: "operator"
            },
            // Punctuation
            {
              match: {
                kind: "string",
                value: ["{", "}", "(", ")", "[", "]", ";", ",", "."]
              },
              token: "punctuation"
            },
            // Whitespace
            {
              match: {
                kind: "charSequence",
                first: { predefined: "whitespace" },
                rest: { predefined: "whitespace" }
              },
              token: "whitespace"
            },
            {
              match: { kind: "charSequence", first: { predefined: "newline" } },
              token: "newline"
            }
          ]
        },
        template_string: {
          rules: [
            // Expression hole ${
            {
              match: { kind: "string", value: "${" },
              token: "template_expr_open",
              push: "template_expr"
            },
            // End of template string
            {
              match: { kind: "string", value: "`" },
              token: "template_end",
              pop: true
            }
            // Template content: any chars (handled by engine consuming until ` or ${)
          ]
        },
        template_expr: {
          rules: [
            // Closing brace ends expression, return to template string
            {
              match: { kind: "string", value: "}" },
              token: "punctuation",
              pop: true
            },
            // Nested template string inside expression
            {
              match: { kind: "string", value: "`" },
              token: "template_start",
              push: "template_string"
            },
            // Block comments
            {
              match: {
                kind: "delimited",
                open: "/*",
                close: "*/",
                multiline: true
              },
              token: "comment"
            },
            // Line comments
            { match: { kind: "line", start: "//" }, token: "comment" },
            // Strings
            {
              match: { kind: "delimited", open: '"', close: '"', escape: "\\" },
              token: "string"
            },
            {
              match: { kind: "delimited", open: "'", close: "'", escape: "\\" },
              token: "string"
            },
            // Numbers
            {
              match: {
                kind: "number",
                integer: true,
                float: true,
                hex: true,
                binary: true,
                octal: true,
                scientific: true,
                separator: "_"
              },
              token: "number"
            },
            // Keywords
            {
              match: {
                kind: "keywords",
                words: [
                  "break",
                  "case",
                  "catch",
                  "class",
                  "const",
                  "continue",
                  "debugger",
                  "default",
                  "delete",
                  "do",
                  "else",
                  "export",
                  "extends",
                  "finally",
                  "for",
                  "function",
                  "if",
                  "import",
                  "in",
                  "instanceof",
                  "let",
                  "new",
                  "return",
                  "super",
                  "switch",
                  "this",
                  "throw",
                  "try",
                  "typeof",
                  "var",
                  "void",
                  "while",
                  "with",
                  "yield",
                  "async",
                  "await",
                  "of"
                ]
              },
              token: "keyword"
            },
            // Constants
            {
              match: {
                kind: "keywords",
                words: ["true", "false", "null", "undefined", "NaN", "Infinity"]
              },
              token: "constant"
            },
            // Identifiers
            {
              match: {
                kind: "charSequence",
                first: { ref: "identStart" },
                rest: { ref: "identPart" }
              },
              token: "identifier"
            },
            // Operators
            {
              match: {
                kind: "string",
                value: [
                  "===",
                  "!==",
                  "==",
                  "!=",
                  ">=",
                  "<=",
                  "&&",
                  "||",
                  "??",
                  "?.",
                  "**",
                  "++",
                  "--",
                  "+=",
                  "-=",
                  "*=",
                  "/=",
                  "%=",
                  "=>",
                  "<<",
                  ">>",
                  ">>>",
                  "..."
                ]
              },
              token: "operator"
            },
            {
              match: {
                kind: "string",
                value: ["+", "-", "*", "/", "%", "=", "!", "<", ">", "&", "|", "^", "~", "?", ":"]
              },
              token: "operator"
            },
            // Punctuation (but NOT }, which is handled above)
            {
              match: {
                kind: "string",
                value: ["{", "(", ")", "[", "]", ";", ",", "."]
              },
              token: "punctuation"
            },
            // Nested braces: push another template_expr to track brace depth
            // (handled by engine via block tracking)
            // Whitespace
            {
              match: {
                kind: "charSequence",
                first: { predefined: "whitespace" },
                rest: { predefined: "whitespace" }
              },
              token: "whitespace"
            },
            {
              match: { kind: "charSequence", first: { predefined: "newline" } },
              token: "newline"
            }
          ]
        }
      }
    },
    structure: {
      blocks: [
        { name: "braces", open: "{", close: "}" },
        { name: "parens", open: "(", close: ")" },
        { name: "brackets", open: "[", close: "]" }
      ],
      symbols: [
        {
          name: "function_declaration",
          kind: "function",
          pattern: [
            { token: "keyword", value: "function" },
            { token: "identifier", capture: "name" }
          ],
          hasBody: true,
          bodyStyle: "braces"
        },
        {
          name: "async_function_declaration",
          kind: "function",
          pattern: [
            { token: "keyword", value: "async" },
            { token: "keyword", value: "function" },
            { token: "identifier", capture: "name" }
          ],
          hasBody: true,
          bodyStyle: "braces"
        },
        {
          name: "class_declaration",
          kind: "class",
          pattern: [
            { token: "keyword", value: "class" },
            {
              anyOf: [
                { token: "identifier", capture: "name" },
                { token: "type_name", capture: "name" }
              ]
            }
          ],
          hasBody: true,
          bodyStyle: "braces"
        },
        {
          name: "arrow_function_const",
          kind: "function",
          pattern: [
            { token: "keyword", value: "const" },
            { token: "identifier", capture: "name" },
            { token: "operator", value: "=" },
            { skip: true, maxTokens: 30 },
            { token: "operator", value: "=>" }
          ],
          hasBody: true,
          bodyStyle: "braces"
        },
        {
          name: "arrow_function_let",
          kind: "function",
          pattern: [
            { token: "keyword", value: "let" },
            { token: "identifier", capture: "name" },
            { token: "operator", value: "=" },
            { skip: true, maxTokens: 30 },
            { token: "operator", value: "=>" }
          ],
          hasBody: true,
          bodyStyle: "braces"
        },
        {
          name: "lexical_declaration",
          kind: "variable",
          pattern: [
            {
              anyOf: [
                { token: "keyword", value: "const" },
                { token: "keyword", value: "let" }
              ]
            },
            { token: "identifier", capture: "name" }
          ],
          hasBody: false
        },
        {
          name: "variable_declaration",
          kind: "variable",
          pattern: [
            { token: "keyword", value: "var" },
            { token: "identifier", capture: "name" }
          ],
          hasBody: false
        },
        {
          name: "import_statement",
          kind: "import",
          pattern: [{ token: "keyword", value: "import" }],
          hasBody: false
        },
        {
          name: "export_statement",
          kind: "export",
          pattern: [{ token: "keyword", value: "export" }],
          hasBody: false
        }
      ],
      folding: [
        { open: { token: "punctuation", value: "{" }, close: { token: "punctuation", value: "}" } },
        { open: { token: "comment" }, close: { token: "comment" } }
      ]
    }
  };
  var typescript = {
    name: "typescript",
    displayName: "TypeScript",
    version: "1.0.0",
    fileExtensions: [".ts", ".mts", ".cts", ".tsx"],
    mimeTypes: ["text/typescript", "application/typescript"],
    extends: "javascript",
    lexer: {
      charClasses: {
        identStart: {
          union: [{ predefined: "letter" }, { chars: "_$" }]
        },
        identPart: {
          union: [{ predefined: "alphanumeric" }, { chars: "_$" }]
        }
      },
      tokenTypes: {
        keyword: { category: "keyword" },
        ts_keyword: { category: "keyword", subcategory: "typescript" },
        constant: { category: "constant" },
        identifier: { category: "identifier" },
        type_name: { category: "type" },
        decorator: { category: "decorator" },
        string: { category: "string" },
        template_start: { category: "string", subcategory: "template" },
        template_content: { category: "string", subcategory: "template" },
        template_expr_open: {
          category: "punctuation",
          subcategory: "template"
        },
        template_end: { category: "string", subcategory: "template" },
        number: { category: "number" },
        comment: { category: "comment" },
        operator: { category: "operator" },
        punctuation: { category: "punctuation" },
        jsx_tag_open: { category: "tag" },
        jsx_tag_close: { category: "tag" },
        jsx_tag_end: { category: "tag" },
        whitespace: { category: "whitespace" },
        newline: { category: "newline" }
      },
      initialState: "default",
      skipTokens: ["whitespace", "newline", "comment"],
      states: {
        default: {
          rules: [
            // Block comments
            {
              match: {
                kind: "delimited",
                open: "/*",
                close: "*/",
                multiline: true
              },
              token: "comment"
            },
            // Line comments
            { match: { kind: "line", start: "//" }, token: "comment" },
            // Template strings
            {
              match: { kind: "string", value: "`" },
              token: "template_start",
              push: "template_string"
            },
            // Strings
            {
              match: { kind: "delimited", open: '"', close: '"', escape: "\\" },
              token: "string"
            },
            {
              match: { kind: "delimited", open: "'", close: "'", escape: "\\" },
              token: "string"
            },
            // Decorators
            {
              match: {
                kind: "sequence",
                elements: [
                  { kind: "string", value: "@" },
                  {
                    kind: "charSequence",
                    first: { ref: "identStart" },
                    rest: {
                      union: [{ predefined: "alphanumeric" }, { chars: "_$." }]
                    }
                  }
                ]
              },
              token: "decorator"
            },
            // Numbers
            {
              match: {
                kind: "number",
                integer: true,
                float: true,
                hex: true,
                binary: true,
                octal: true,
                scientific: true,
                separator: "_"
              },
              token: "number"
            },
            // TypeScript-specific keywords
            {
              match: {
                kind: "keywords",
                words: [
                  "interface",
                  "type",
                  "enum",
                  "namespace",
                  "module",
                  "declare",
                  "abstract",
                  "implements",
                  "readonly",
                  "public",
                  "private",
                  "protected",
                  "override",
                  "keyof",
                  "infer",
                  "is",
                  "asserts",
                  "satisfies",
                  "as",
                  "unknown",
                  "never",
                  "any"
                ]
              },
              token: "ts_keyword"
            },
            // JavaScript keywords
            {
              match: {
                kind: "keywords",
                words: [
                  "break",
                  "case",
                  "catch",
                  "class",
                  "const",
                  "continue",
                  "debugger",
                  "default",
                  "delete",
                  "do",
                  "else",
                  "export",
                  "extends",
                  "finally",
                  "for",
                  "function",
                  "if",
                  "import",
                  "in",
                  "instanceof",
                  "let",
                  "new",
                  "return",
                  "super",
                  "switch",
                  "this",
                  "throw",
                  "try",
                  "typeof",
                  "var",
                  "void",
                  "while",
                  "with",
                  "yield",
                  "async",
                  "await",
                  "of",
                  "static",
                  "get",
                  "set",
                  "from"
                ]
              },
              token: "keyword"
            },
            // Constants
            {
              match: {
                kind: "keywords",
                words: ["true", "false", "null", "undefined", "NaN", "Infinity"]
              },
              token: "constant"
            },
            // Type-like identifiers (PascalCase)
            {
              match: {
                kind: "charSequence",
                first: { range: ["A", "Z"] },
                rest: { ref: "identPart" }
              },
              token: "type_name"
            },
            // Identifiers
            {
              match: {
                kind: "charSequence",
                first: { ref: "identStart" },
                rest: { ref: "identPart" }
              },
              token: "identifier"
            },
            // Multi-char operators
            {
              match: {
                kind: "string",
                value: [
                  ">>>=",
                  "<<=",
                  ">>=",
                  "**=",
                  "&&=",
                  "||=",
                  "??=",
                  "===",
                  "!==",
                  ">>>",
                  "...",
                  "==",
                  "!=",
                  ">=",
                  "<=",
                  "&&",
                  "||",
                  "??",
                  "?.",
                  "**",
                  "++",
                  "--",
                  "+=",
                  "-=",
                  "*=",
                  "/=",
                  "%=",
                  "&=",
                  "|=",
                  "^=",
                  "=>",
                  "<<",
                  ">>"
                ]
              },
              token: "operator"
            },
            // Single-char operators
            {
              match: {
                kind: "string",
                value: [
                  "+",
                  "-",
                  "*",
                  "/",
                  "%",
                  "=",
                  "!",
                  "<",
                  ">",
                  "&",
                  "|",
                  "^",
                  "~",
                  "?",
                  ":"
                ]
              },
              token: "operator"
            },
            // Punctuation
            {
              match: {
                kind: "string",
                value: ["{", "}", "(", ")", "[", "]", ";", ",", "."]
              },
              token: "punctuation"
            },
            // Whitespace
            {
              match: {
                kind: "charSequence",
                first: { predefined: "whitespace" },
                rest: { predefined: "whitespace" }
              },
              token: "whitespace"
            },
            {
              match: { kind: "charSequence", first: { predefined: "newline" } },
              token: "newline"
            }
          ]
        },
        template_string: {
          rules: [
            {
              match: { kind: "string", value: "${" },
              token: "template_expr_open",
              push: "template_expr"
            },
            {
              match: { kind: "string", value: "`" },
              token: "template_end",
              pop: true
            }
          ]
        },
        template_expr: {
          rules: [
            {
              match: { kind: "string", value: "}" },
              token: "punctuation",
              pop: true
            },
            {
              match: { kind: "string", value: "`" },
              token: "template_start",
              push: "template_string"
            },
            {
              match: {
                kind: "delimited",
                open: "/*",
                close: "*/",
                multiline: true
              },
              token: "comment"
            },
            { match: { kind: "line", start: "//" }, token: "comment" },
            {
              match: { kind: "delimited", open: '"', close: '"', escape: "\\" },
              token: "string"
            },
            {
              match: { kind: "delimited", open: "'", close: "'", escape: "\\" },
              token: "string"
            },
            {
              match: {
                kind: "number",
                integer: true,
                float: true,
                hex: true,
                binary: true,
                octal: true,
                scientific: true,
                separator: "_"
              },
              token: "number"
            },
            {
              match: {
                kind: "keywords",
                words: [
                  "break",
                  "case",
                  "catch",
                  "class",
                  "const",
                  "continue",
                  "delete",
                  "do",
                  "else",
                  "export",
                  "extends",
                  "finally",
                  "for",
                  "function",
                  "if",
                  "import",
                  "in",
                  "instanceof",
                  "let",
                  "new",
                  "return",
                  "super",
                  "switch",
                  "this",
                  "throw",
                  "try",
                  "typeof",
                  "var",
                  "void",
                  "while",
                  "with",
                  "yield",
                  "async",
                  "await",
                  "of",
                  "interface",
                  "type",
                  "enum",
                  "as",
                  "keyof"
                ]
              },
              token: "keyword"
            },
            {
              match: {
                kind: "keywords",
                words: ["true", "false", "null", "undefined"]
              },
              token: "constant"
            },
            {
              match: {
                kind: "charSequence",
                first: { ref: "identStart" },
                rest: { ref: "identPart" }
              },
              token: "identifier"
            },
            {
              match: {
                kind: "string",
                value: [
                  "===",
                  "!==",
                  "==",
                  "!=",
                  ">=",
                  "<=",
                  "&&",
                  "||",
                  "??",
                  "?.",
                  "**",
                  "++",
                  "--",
                  "+=",
                  "-=",
                  "*=",
                  "/=",
                  "%=",
                  "=>",
                  "<<",
                  ">>",
                  ">>>",
                  "..."
                ]
              },
              token: "operator"
            },
            {
              match: {
                kind: "string",
                value: ["+", "-", "*", "/", "%", "=", "!", "<", ">", "&", "|", "^", "~", "?", ":"]
              },
              token: "operator"
            },
            {
              match: {
                kind: "string",
                value: ["{", "(", ")", "[", "]", ";", ",", "."]
              },
              token: "punctuation"
            },
            {
              match: {
                kind: "charSequence",
                first: { predefined: "whitespace" },
                rest: { predefined: "whitespace" }
              },
              token: "whitespace"
            },
            {
              match: { kind: "charSequence", first: { predefined: "newline" } },
              token: "newline"
            }
          ]
        }
      }
    },
    structure: {
      blocks: [
        { name: "braces", open: "{", close: "}" },
        { name: "parens", open: "(", close: ")" },
        { name: "brackets", open: "[", close: "]" }
      ],
      symbols: [
        {
          name: "function_declaration",
          kind: "function",
          pattern: [
            { token: "keyword", value: "function" },
            { token: "identifier", capture: "name" }
          ],
          hasBody: true,
          bodyStyle: "braces"
        },
        {
          name: "async_function_declaration",
          kind: "function",
          pattern: [
            { token: "keyword", value: "async" },
            { token: "keyword", value: "function" },
            { token: "identifier", capture: "name" }
          ],
          hasBody: true,
          bodyStyle: "braces"
        },
        {
          name: "class_declaration",
          kind: "class",
          pattern: [
            { token: "keyword", value: "class" },
            {
              anyOf: [
                { token: "identifier", capture: "name" },
                { token: "type_name", capture: "name" }
              ]
            }
          ],
          hasBody: true,
          bodyStyle: "braces"
        },
        {
          name: "abstract_class_declaration",
          kind: "class",
          pattern: [
            { token: "ts_keyword", value: "abstract" },
            { token: "keyword", value: "class" },
            {
              anyOf: [
                { token: "identifier", capture: "name" },
                { token: "type_name", capture: "name" }
              ]
            }
          ],
          hasBody: true,
          bodyStyle: "braces"
        },
        {
          name: "interface_declaration",
          kind: "interface",
          pattern: [
            { token: "ts_keyword", value: "interface" },
            { token: "type_name", capture: "name" }
          ],
          hasBody: true,
          bodyStyle: "braces"
        },
        {
          name: "type_alias_declaration",
          kind: "type",
          pattern: [
            { token: "ts_keyword", value: "type" },
            { token: "type_name", capture: "name" }
          ],
          hasBody: false
        },
        {
          name: "enum_declaration",
          kind: "enum",
          pattern: [
            { token: "ts_keyword", value: "enum" },
            {
              anyOf: [
                { token: "identifier", capture: "name" },
                { token: "type_name", capture: "name" }
              ]
            }
          ],
          hasBody: true,
          bodyStyle: "braces"
        },
        {
          name: "namespace_declaration",
          kind: "namespace",
          pattern: [
            { token: "ts_keyword", value: "namespace" },
            {
              anyOf: [
                { token: "identifier", capture: "name" },
                { token: "type_name", capture: "name" }
              ]
            }
          ],
          hasBody: true,
          bodyStyle: "braces"
        },
        {
          name: "arrow_function_const",
          kind: "function",
          pattern: [
            { token: "keyword", value: "const" },
            { token: "identifier", capture: "name" },
            { token: "operator", value: "=" },
            { skip: true, maxTokens: 50 },
            { token: "operator", value: "=>" }
          ],
          hasBody: true,
          bodyStyle: "braces"
        },
        {
          name: "lexical_declaration",
          kind: "variable",
          pattern: [
            {
              anyOf: [
                { token: "keyword", value: "const" },
                { token: "keyword", value: "let" }
              ]
            },
            { token: "identifier", capture: "name" }
          ],
          hasBody: false
        },
        {
          name: "variable_declaration",
          kind: "variable",
          pattern: [
            { token: "keyword", value: "var" },
            { token: "identifier", capture: "name" }
          ],
          hasBody: false
        },
        {
          name: "import_statement",
          kind: "import",
          pattern: [{ token: "keyword", value: "import" }],
          hasBody: false
        },
        {
          name: "export_statement",
          kind: "export",
          pattern: [{ token: "keyword", value: "export" }],
          hasBody: false
        }
      ],
      folding: [
        { open: { token: "punctuation", value: "{" }, close: { token: "punctuation", value: "}" } }
      ]
    }
  };
  var cpp = {
    name: "cpp",
    displayName: "C++",
    version: "1.0.0",
    fileExtensions: [".cpp", ".hpp", ".cc", ".hh", ".cxx", ".hxx", ".h"],
    mimeTypes: ["text/x-c++src"],
    lexer: {
      charClasses: {
        identStart: {
          union: [{ predefined: "letter" }, { chars: "_" }]
        },
        identPart: {
          union: [{ predefined: "alphanumeric" }, { chars: "_" }]
        }
      },
      tokenTypes: {
        keyword: { category: "keyword" },
        type_keyword: { category: "type", subcategory: "builtin" },
        constant: { category: "constant" },
        identifier: { category: "identifier" },
        type_name: { category: "type" },
        preprocessor: { category: "meta", subcategory: "preprocessor" },
        string: { category: "string" },
        char_literal: { category: "string", subcategory: "char" },
        raw_string: { category: "string", subcategory: "raw" },
        number: { category: "number" },
        comment: { category: "comment" },
        operator: { category: "operator" },
        punctuation: { category: "punctuation" },
        whitespace: { category: "whitespace" },
        newline: { category: "newline" }
      },
      initialState: "default",
      skipTokens: ["whitespace", "newline", "comment"],
      states: {
        default: {
          rules: [
            // Block comments
            {
              match: {
                kind: "delimited",
                open: "/*",
                close: "*/",
                multiline: true
              },
              token: "comment"
            },
            // Line comments
            { match: { kind: "line", start: "//" }, token: "comment" },
            // Preprocessor directives
            { match: { kind: "line", start: "#" }, token: "preprocessor" },
            // Raw strings R"delimiter(content)delimiter"
            {
              match: {
                kind: "pattern",
                regex: 'R"([^(\\s]*)\\([\\s\\S]*?\\)\\1"'
              },
              token: "raw_string"
            },
            // Regular strings
            {
              match: { kind: "delimited", open: '"', close: '"', escape: "\\" },
              token: "string"
            },
            // Character literals
            {
              match: { kind: "delimited", open: "'", close: "'", escape: "\\" },
              token: "char_literal"
            },
            // Numbers
            {
              match: {
                kind: "number",
                integer: true,
                float: true,
                hex: true,
                octal: true,
                binary: true,
                scientific: true,
                separator: "'",
                suffix: ["u", "U", "l", "L", "ll", "LL", "ul", "UL", "ull", "ULL", "f", "F"]
              },
              token: "number"
            },
            // C++ keywords
            {
              match: {
                kind: "keywords",
                words: [
                  "alignas",
                  "alignof",
                  "and",
                  "and_eq",
                  "asm",
                  "auto",
                  "bitand",
                  "bitor",
                  "break",
                  "case",
                  "catch",
                  "class",
                  "compl",
                  "concept",
                  "const",
                  "consteval",
                  "constexpr",
                  "constinit",
                  "const_cast",
                  "continue",
                  "co_await",
                  "co_return",
                  "co_yield",
                  "decltype",
                  "default",
                  "delete",
                  "do",
                  "dynamic_cast",
                  "else",
                  "enum",
                  "explicit",
                  "export",
                  "extern",
                  "for",
                  "friend",
                  "goto",
                  "if",
                  "inline",
                  "mutable",
                  "namespace",
                  "new",
                  "noexcept",
                  "not",
                  "not_eq",
                  "operator",
                  "or",
                  "or_eq",
                  "private",
                  "protected",
                  "public",
                  "register",
                  "reinterpret_cast",
                  "requires",
                  "return",
                  "sizeof",
                  "static",
                  "static_assert",
                  "static_cast",
                  "struct",
                  "switch",
                  "template",
                  "this",
                  "throw",
                  "try",
                  "typedef",
                  "typeid",
                  "typename",
                  "union",
                  "using",
                  "virtual",
                  "volatile",
                  "while",
                  "xor",
                  "xor_eq",
                  "override",
                  "final"
                ]
              },
              token: "keyword"
            },
            // Built-in types
            {
              match: {
                kind: "keywords",
                words: [
                  "void",
                  "bool",
                  "char",
                  "char8_t",
                  "char16_t",
                  "char32_t",
                  "wchar_t",
                  "short",
                  "int",
                  "long",
                  "float",
                  "double",
                  "signed",
                  "unsigned",
                  "size_t",
                  "ptrdiff_t",
                  "nullptr_t",
                  "int8_t",
                  "int16_t",
                  "int32_t",
                  "int64_t",
                  "uint8_t",
                  "uint16_t",
                  "uint32_t",
                  "uint64_t"
                ]
              },
              token: "type_keyword"
            },
            // Constants
            {
              match: {
                kind: "keywords",
                words: ["true", "false", "nullptr", "NULL"]
              },
              token: "constant"
            },
            // Type-like identifiers (PascalCase)
            {
              match: {
                kind: "charSequence",
                first: { range: ["A", "Z"] },
                rest: { ref: "identPart" }
              },
              token: "type_name"
            },
            // Identifiers
            {
              match: {
                kind: "charSequence",
                first: { ref: "identStart" },
                rest: { ref: "identPart" }
              },
              token: "identifier"
            },
            // Multi-char operators
            {
              match: {
                kind: "string",
                value: [
                  "<<=",
                  ">>=",
                  "<=>",
                  "->*",
                  "==",
                  "!=",
                  ">=",
                  "<=",
                  "&&",
                  "||",
                  "<<",
                  ">>",
                  "++",
                  "--",
                  "+=",
                  "-=",
                  "*=",
                  "/=",
                  "%=",
                  "&=",
                  "|=",
                  "^=",
                  "->",
                  "::",
                  ".*",
                  "..."
                ]
              },
              token: "operator"
            },
            // Single-char operators
            {
              match: {
                kind: "string",
                value: ["+", "-", "*", "/", "%", "=", "!", "<", ">", "&", "|", "^", "~", "?", ":"]
              },
              token: "operator"
            },
            // Punctuation
            {
              match: {
                kind: "string",
                value: ["{", "}", "(", ")", "[", "]", ";", ",", "."]
              },
              token: "punctuation"
            },
            // Whitespace
            {
              match: {
                kind: "charSequence",
                first: { predefined: "whitespace" },
                rest: { predefined: "whitespace" }
              },
              token: "whitespace"
            },
            {
              match: { kind: "charSequence", first: { predefined: "newline" } },
              token: "newline"
            }
          ]
        }
      }
    },
    structure: {
      blocks: [
        { name: "braces", open: "{", close: "}" },
        { name: "parens", open: "(", close: ")" },
        { name: "brackets", open: "[", close: "]" }
      ],
      symbols: [
        {
          name: "function_definition",
          kind: "function",
          pattern: [
            {
              anyOf: [
                { token: "type_keyword" },
                { token: "type_name" },
                { token: "identifier" }
              ]
            },
            { token: "identifier", capture: "name" },
            { token: "punctuation", value: "(" }
          ],
          hasBody: true,
          bodyStyle: "braces"
        },
        {
          name: "class_specifier",
          kind: "class",
          pattern: [
            { token: "keyword", value: "class" },
            { token: "identifier", capture: "name" }
          ],
          hasBody: true,
          bodyStyle: "braces"
        },
        {
          name: "struct_specifier",
          kind: "class",
          pattern: [
            { token: "keyword", value: "struct" },
            { token: "identifier", capture: "name" }
          ],
          hasBody: true,
          bodyStyle: "braces"
        },
        {
          name: "enum_specifier",
          kind: "enum",
          pattern: [
            { token: "keyword", value: "enum" },
            { optional: { token: "keyword", value: "class" } },
            { token: "identifier", capture: "name" }
          ],
          hasBody: true,
          bodyStyle: "braces"
        },
        {
          name: "namespace_definition",
          kind: "namespace",
          pattern: [
            { token: "keyword", value: "namespace" },
            { token: "identifier", capture: "name" }
          ],
          hasBody: true,
          bodyStyle: "braces"
        },
        {
          name: "template_declaration",
          kind: "other",
          pattern: [
            { token: "keyword", value: "template" },
            { token: "operator", value: "<" }
          ],
          hasBody: false
        },
        {
          name: "typedef_declaration",
          kind: "type",
          pattern: [{ token: "keyword", value: "typedef" }],
          hasBody: false
        },
        {
          name: "using_declaration",
          kind: "type",
          pattern: [
            { token: "keyword", value: "using" },
            { token: "identifier", capture: "name" }
          ],
          hasBody: false
        }
      ],
      folding: [
        { open: { token: "punctuation", value: "{" }, close: { token: "punctuation", value: "}" } },
        { open: { token: "preprocessor" }, close: { token: "preprocessor" } }
      ]
    }
  };
  var html = {
    name: "html",
    displayName: "HTML",
    version: "1.0.0",
    fileExtensions: [".html", ".htm"],
    mimeTypes: ["text/html"],
    lexer: {
      charClasses: {
        tagNameChar: {
          union: [{ predefined: "alphanumeric" }, { chars: "-_" }]
        },
        attrNameChar: {
          union: [{ predefined: "alphanumeric" }, { chars: "-_:." }]
        }
      },
      tokenTypes: {
        comment: { category: "comment" },
        doctype: { category: "meta", subcategory: "doctype" },
        tag_open: { category: "tag" },
        tag_close: { category: "tag" },
        tag_self_close: { category: "tag" },
        tag_name: { category: "tag", subcategory: "name" },
        attr_name: { category: "attribute" },
        attr_eq: { category: "operator" },
        string: { category: "string" },
        text: { category: "plain" },
        entity: { category: "escape" },
        whitespace: { category: "whitespace" },
        newline: { category: "newline" }
      },
      initialState: "content",
      skipTokens: ["whitespace", "newline"],
      states: {
        content: {
          rules: [
            // HTML comments
            {
              match: {
                kind: "delimited",
                open: "<!--",
                close: "-->",
                multiline: true
              },
              token: "comment"
            },
            // DOCTYPE
            {
              match: {
                kind: "pattern",
                regex: "<!DOCTYPE[^>]*>"
              },
              token: "doctype"
            },
            // Closing tag
            {
              match: { kind: "string", value: "</" },
              token: "tag_close",
              push: "tag"
            },
            // Opening tag
            {
              match: { kind: "string", value: "<" },
              token: "tag_open",
              push: "tag"
            },
            // HTML entities
            {
              match: {
                kind: "pattern",
                regex: "&(?:#[0-9]+|#x[0-9a-fA-F]+|[a-zA-Z]+);"
              },
              token: "entity"
            },
            // Whitespace
            {
              match: {
                kind: "charSequence",
                first: { predefined: "whitespace" },
                rest: { predefined: "whitespace" }
              },
              token: "whitespace"
            },
            {
              match: { kind: "charSequence", first: { predefined: "newline" } },
              token: "newline"
            },
            // Text content (any non-tag, non-entity content)
            {
              match: {
                kind: "charSequence",
                first: { negate: { chars: "<&" } },
                rest: { negate: { chars: "<&" } }
              },
              token: "text"
            }
          ]
        },
        tag: {
          rules: [
            // Self-closing tag end
            {
              match: { kind: "string", value: "/>" },
              token: "tag_self_close",
              pop: true
            },
            // Tag end
            {
              match: { kind: "string", value: ">" },
              token: "tag_open",
              pop: true
            },
            // Tag name
            {
              match: {
                kind: "charSequence",
                first: { predefined: "letter" },
                rest: { ref: "tagNameChar" }
              },
              token: "tag_name"
            },
            // Attribute name
            {
              match: {
                kind: "charSequence",
                first: { predefined: "letter" },
                rest: { ref: "attrNameChar" }
              },
              token: "attr_name"
            },
            // Attribute =
            { match: { kind: "string", value: "=" }, token: "attr_eq" },
            // Attribute values
            {
              match: { kind: "delimited", open: '"', close: '"', escape: "\\" },
              token: "string"
            },
            {
              match: { kind: "delimited", open: "'", close: "'", escape: "\\" },
              token: "string"
            },
            // Whitespace
            {
              match: {
                kind: "charSequence",
                first: { predefined: "whitespace" },
                rest: { predefined: "whitespace" }
              },
              token: "whitespace"
            },
            {
              match: { kind: "charSequence", first: { predefined: "newline" } },
              token: "newline"
            }
          ]
        }
      }
    },
    structure: {
      blocks: [],
      symbols: []
    },
    embeddedLanguages: [
      {
        language: "css",
        start: { token: "tag_name", value: "style" },
        end: { token: "tag_close" },
        languageDetection: "fixed"
      },
      {
        language: "javascript",
        start: { token: "tag_name", value: "script" },
        end: { token: "tag_close" },
        languageDetection: "attribute",
        attributeToken: "string"
      }
    ]
  };
  var markdown = {
    name: "markdown",
    displayName: "Markdown",
    version: "1.0.0",
    fileExtensions: [".md", ".markdown", ".mdx"],
    mimeTypes: ["text/markdown"],
    lexer: {
      tokenTypes: {
        heading: { category: "keyword", subcategory: "heading" },
        code_fence_open: { category: "meta", subcategory: "code-fence" },
        code_fence_close: { category: "meta", subcategory: "code-fence" },
        code_content: { category: "string", subcategory: "code" },
        code_language: { category: "identifier", subcategory: "language" },
        inline_code: { category: "string", subcategory: "inline-code" },
        bold: { category: "keyword", subcategory: "bold" },
        italic: { category: "keyword", subcategory: "italic" },
        link_text: { category: "string", subcategory: "link-text" },
        link_url: { category: "variable", subcategory: "link-url" },
        image_marker: { category: "keyword", subcategory: "image" },
        list_marker: { category: "punctuation", subcategory: "list" },
        blockquote: { category: "punctuation", subcategory: "blockquote" },
        hr: { category: "punctuation", subcategory: "hr" },
        html_tag: { category: "tag" },
        text: { category: "plain" },
        whitespace: { category: "whitespace" },
        newline: { category: "newline" }
      },
      initialState: "default",
      skipTokens: [],
      states: {
        default: {
          rules: [
            // Fenced code block open (``` or ~~~)
            {
              match: {
                kind: "sequence",
                elements: [
                  { kind: "string", value: ["```", "~~~"] },
                  {
                    kind: "charSequence",
                    first: { predefined: "letter" },
                    rest: {
                      union: [{ predefined: "alphanumeric" }, { chars: "-_+." }]
                    }
                  }
                ]
              },
              token: "code_fence_open",
              push: "code_block"
            },
            // Fenced code block without language
            {
              match: { kind: "string", value: ["```", "~~~"] },
              token: "code_fence_open",
              push: "code_block"
            },
            // Headings (# through ######)
            {
              match: {
                kind: "sequence",
                elements: [
                  { kind: "string", value: ["######", "#####", "####", "###", "##", "#"] },
                  { kind: "charSequence", first: { predefined: "whitespace" } }
                ]
              },
              token: "heading"
            },
            // Inline code
            {
              match: {
                kind: "delimited",
                open: "``",
                close: "``"
              },
              token: "inline_code"
            },
            {
              match: {
                kind: "delimited",
                open: "`",
                close: "`"
              },
              token: "inline_code"
            },
            // Bold
            {
              match: {
                kind: "delimited",
                open: "**",
                close: "**"
              },
              token: "bold"
            },
            {
              match: {
                kind: "delimited",
                open: "__",
                close: "__"
              },
              token: "bold"
            },
            // Italic
            {
              match: {
                kind: "delimited",
                open: "*",
                close: "*"
              },
              token: "italic"
            },
            {
              match: {
                kind: "delimited",
                open: "_",
                close: "_"
              },
              token: "italic"
            },
            // Image
            {
              match: { kind: "string", value: "![" },
              token: "image_marker"
            },
            // Link text [text](url)
            {
              match: {
                kind: "delimited",
                open: "[",
                close: "]"
              },
              token: "link_text"
            },
            {
              match: {
                kind: "delimited",
                open: "(",
                close: ")"
              },
              token: "link_url"
            },
            // Horizontal rule
            {
              match: { kind: "string", value: ["---", "***", "___"] },
              token: "hr"
            },
            // Blockquote
            {
              match: {
                kind: "sequence",
                elements: [
                  { kind: "string", value: ">" },
                  {
                    kind: "charSequence",
                    first: { predefined: "whitespace" }
                  }
                ]
              },
              token: "blockquote"
            },
            // Unordered list markers
            {
              match: {
                kind: "sequence",
                elements: [
                  { kind: "string", value: ["-", "*", "+"] },
                  {
                    kind: "charSequence",
                    first: { predefined: "whitespace" }
                  }
                ]
              },
              token: "list_marker"
            },
            // Ordered list markers (1. 2. etc.)
            {
              match: {
                kind: "sequence",
                elements: [
                  {
                    kind: "charSequence",
                    first: { predefined: "digit" },
                    rest: { predefined: "digit" }
                  },
                  { kind: "string", value: "." },
                  {
                    kind: "charSequence",
                    first: { predefined: "whitespace" }
                  }
                ]
              },
              token: "list_marker"
            },
            // HTML inline tags
            {
              match: {
                kind: "pattern",
                regex: "</?[a-zA-Z][a-zA-Z0-9-]*[^>]*>"
              },
              token: "html_tag"
            },
            // Whitespace
            {
              match: {
                kind: "charSequence",
                first: { predefined: "whitespace" },
                rest: { predefined: "whitespace" }
              },
              token: "whitespace"
            },
            {
              match: { kind: "charSequence", first: { predefined: "newline" } },
              token: "newline"
            },
            // Text (any remaining content)
            {
              match: {
                kind: "charSequence",
                first: {
                  negate: {
                    union: [
                      { predefined: "whitespace" },
                      { predefined: "newline" }
                    ]
                  }
                },
                rest: {
                  negate: {
                    union: [
                      { chars: "`*_[](!)#>-+" },
                      { predefined: "newline" }
                    ]
                  }
                }
              },
              token: "text"
            }
          ]
        },
        code_block: {
          rules: [
            // Close fence
            {
              match: { kind: "string", value: ["```", "~~~"] },
              token: "code_fence_close",
              pop: true
            },
            // Code content (any line)
            {
              match: { kind: "charSequence", first: { predefined: "newline" } },
              token: "newline"
            },
            {
              match: {
                kind: "charSequence",
                first: { predefined: "any" },
                rest: { negate: { predefined: "newline" } }
              },
              token: "code_content"
            }
          ]
        }
      }
    },
    structure: {
      blocks: [],
      symbols: [
        {
          name: "heading",
          kind: "other",
          pattern: [{ token: "heading", capture: "name" }],
          hasBody: false
        },
        {
          name: "fenced_code_block",
          kind: "other",
          pattern: [{ token: "code_fence_open", capture: "name" }],
          hasBody: true,
          bodyStyle: "braces"
        }
      ]
    },
    embeddedLanguages: [
      {
        language: "javascript",
        start: { token: "code_fence_open", value: "```javascript" },
        end: { token: "code_fence_close" },
        languageDetection: "attribute",
        attributeToken: "code_language"
      }
    ]
  };
  function createGenericCodeProfile(options) {
    var _a;
    const {
      name,
      displayName,
      fileExtensions,
      mimeTypes,
      keywords = [],
      lineComment,
      blockComment,
      stringDelimiters = ['"', "'"]
    } = options;
    const keywordSet = new Set(keywords.map((keyword) => keyword.toLowerCase()));
    const classKeywords = ["class", "struct", "interface", "enum", "trait", "protocol", "object"];
    const functionKeywords = ["function", "fn", "def", "fun", "func", "sub"];
    const namespaceKeywords = ["namespace", "package", "module"];
    const sqlObjectKeywords = [
      "table",
      "view",
      "function",
      "procedure",
      "trigger",
      "index",
      "schema",
      "database"
    ];
    const availableClassKeywords = classKeywords.filter((keyword) => keywordSet.has(keyword));
    const availableFunctionKeywords = functionKeywords.filter((keyword) => keywordSet.has(keyword));
    const availableNamespaceKeywords = namespaceKeywords.filter((keyword) => keywordSet.has(keyword));
    const hasSqlCreate = keywordSet.has("create") && sqlObjectKeywords.some((keyword) => keywordSet.has(keyword));
    const symbols = [];
    if (availableClassKeywords.length > 0) {
      symbols.push({
        name: "class_declaration",
        kind: "class",
        pattern: [
          {
            anyOf: availableClassKeywords.map((keyword) => ({ token: "keyword", value: keyword }))
          },
          { token: "identifier", capture: "name" }
        ],
        hasBody: false
      });
    }
    if (availableFunctionKeywords.length > 0) {
      symbols.push({
        name: "function_declaration",
        kind: "function",
        pattern: [
          {
            anyOf: availableFunctionKeywords.map((keyword) => ({ token: "keyword", value: keyword }))
          },
          { token: "identifier", capture: "name" }
        ],
        hasBody: false
      });
    }
    if (availableNamespaceKeywords.length > 0) {
      symbols.push({
        name: "namespace_declaration",
        kind: "namespace",
        pattern: [
          {
            anyOf: availableNamespaceKeywords.map((keyword) => ({ token: "keyword", value: keyword }))
          },
          { token: "identifier", capture: "name" }
        ],
        hasBody: false
      });
    }
    if (hasSqlCreate) {
      symbols.push({
        name: "create_statement",
        kind: "object",
        pattern: [
          { token: "keyword", value: "create" },
          {
            optional: {
              anyOf: [
                { token: "keyword", value: "or" },
                { token: "keyword", value: "replace" }
              ]
            }
          },
          {
            optional: {
              anyOf: [
                { token: "keyword", value: "or" },
                { token: "keyword", value: "replace" }
              ]
            }
          },
          {
            anyOf: sqlObjectKeywords.filter((keyword) => keywordSet.has(keyword)).map((keyword) => ({ token: "keyword", value: keyword }))
          },
          { token: "identifier", capture: "name" }
        ],
        hasBody: false
      });
    }
    const rules = [];
    if (blockComment) {
      rules.push({
        match: {
          kind: "delimited",
          open: blockComment.open,
          close: blockComment.close,
          multiline: true,
          nested: (_a = blockComment.nested) != null ? _a : false
        },
        token: "comment"
      });
    }
    if (lineComment) {
      rules.push({
        match: { kind: "line", start: lineComment },
        token: "comment"
      });
    }
    for (const delimiter of stringDelimiters) {
      rules.push({
        match: { kind: "delimited", open: delimiter, close: delimiter, escape: "\\" },
        token: "string"
      });
    }
    rules.push({
      match: {
        kind: "number",
        integer: true,
        float: true,
        scientific: true,
        hex: true,
        octal: true,
        binary: true,
        separator: "_"
      },
      token: "number"
    });
    if (keywords.length > 0) {
      rules.push({
        match: { kind: "keywords", words: keywords },
        token: "keyword"
      });
    }
    rules.push(
      {
        match: {
          kind: "charSequence",
          first: { ref: "identStart" },
          rest: { ref: "identPart" }
        },
        token: "identifier"
      },
      {
        match: {
          kind: "string",
          value: [
            "===",
            "!==",
            "==",
            "!=",
            "<=",
            ">=",
            "=>",
            "->",
            "::",
            "&&",
            "||",
            "??",
            "+",
            "-",
            "*",
            "/",
            "%",
            "=",
            "<",
            ">",
            "!",
            "&",
            "|",
            "^",
            "~",
            "?",
            ":",
            "."
          ]
        },
        token: "operator"
      },
      {
        match: {
          kind: "string",
          value: ["{", "}", "(", ")", "[", "]", ",", ";"]
        },
        token: "punctuation"
      },
      {
        match: {
          kind: "charSequence",
          first: { predefined: "whitespace" },
          rest: { predefined: "whitespace" }
        },
        token: "whitespace"
      },
      {
        match: { kind: "charSequence", first: { predefined: "newline" } },
        token: "newline"
      },
      {
        match: {
          kind: "charSequence",
          first: { predefined: "any" },
          rest: { negate: { predefined: "newline" } }
        },
        token: "text"
      }
    );
    return {
      name,
      displayName,
      version: "1.0.0",
      fileExtensions,
      mimeTypes,
      lexer: {
        charClasses: {
          identStart: {
            union: [{ predefined: "letter" }, { chars: "_$" }]
          },
          identPart: {
            union: [{ predefined: "alphanumeric" }, { chars: "_$" }]
          }
        },
        tokenTypes: {
          comment: { category: "comment" },
          string: { category: "string" },
          number: { category: "number" },
          keyword: { category: "keyword" },
          identifier: { category: "identifier" },
          operator: { category: "operator" },
          punctuation: { category: "punctuation" },
          text: { category: "plain" },
          whitespace: { category: "whitespace" },
          newline: { category: "newline" }
        },
        initialState: "default",
        skipTokens: ["whitespace", "newline"],
        states: {
          default: {
            rules
          }
        }
      },
      structure: {
        blocks: [{ name: "braces", open: "{", close: "}" }],
        symbols
      }
    };
  }
  function createMarkupProfile(options) {
    return {
      name: options.name,
      displayName: options.displayName,
      version: "1.0.0",
      fileExtensions: options.fileExtensions,
      mimeTypes: options.mimeTypes,
      lexer: {
        charClasses: {
          tagNameChar: {
            union: [{ predefined: "alphanumeric" }, { chars: "-_:" }]
          }
        },
        tokenTypes: {
          comment: { category: "comment" },
          cdata: { category: "string", subcategory: "cdata" },
          processing: { category: "meta", subcategory: "processing" },
          tag_open: { category: "tag" },
          tag_close: { category: "tag" },
          tag_name: { category: "tag", subcategory: "name" },
          string: { category: "string" },
          operator: { category: "operator" },
          text: { category: "plain" },
          whitespace: { category: "whitespace" },
          newline: { category: "newline" }
        },
        initialState: "content",
        skipTokens: ["whitespace", "newline"],
        states: {
          content: {
            rules: [
              {
                match: {
                  kind: "delimited",
                  open: "<!--",
                  close: "-->",
                  multiline: true
                },
                token: "comment"
              },
              {
                match: {
                  kind: "delimited",
                  open: "<![CDATA[",
                  close: "]]>",
                  multiline: true
                },
                token: "cdata"
              },
              {
                match: {
                  kind: "delimited",
                  open: "<?",
                  close: "?>",
                  multiline: true
                },
                token: "processing"
              },
              {
                match: { kind: "string", value: "</" },
                token: "tag_close",
                push: "tag"
              },
              {
                match: { kind: "string", value: "<" },
                token: "tag_open",
                push: "tag"
              },
              {
                match: {
                  kind: "charSequence",
                  first: { predefined: "whitespace" },
                  rest: { predefined: "whitespace" }
                },
                token: "whitespace"
              },
              {
                match: { kind: "charSequence", first: { predefined: "newline" } },
                token: "newline"
              },
              {
                match: {
                  kind: "charSequence",
                  first: { negate: { chars: "<" } },
                  rest: { negate: { chars: "<" } }
                },
                token: "text"
              }
            ]
          },
          tag: {
            rules: [
              {
                match: { kind: "string", value: ["/>", ">"] },
                token: "tag_open",
                pop: true
              },
              {
                match: {
                  kind: "charSequence",
                  first: { predefined: "letter" },
                  rest: { ref: "tagNameChar" }
                },
                token: "tag_name"
              },
              {
                match: { kind: "string", value: "=" },
                token: "operator"
              },
              {
                match: { kind: "delimited", open: '"', close: '"', escape: "\\" },
                token: "string"
              },
              {
                match: { kind: "delimited", open: "'", close: "'", escape: "\\" },
                token: "string"
              },
              {
                match: {
                  kind: "charSequence",
                  first: { predefined: "whitespace" },
                  rest: { predefined: "whitespace" }
                },
                token: "whitespace"
              },
              {
                match: { kind: "charSequence", first: { predefined: "newline" } },
                token: "newline"
              }
            ]
          }
        }
      },
      structure: {
        blocks: [],
        symbols: []
      }
    };
  }
  function createYamlProfile(name, displayName, fileExtensions, mimeTypes) {
    return {
      name,
      displayName,
      version: "1.0.0",
      fileExtensions,
      mimeTypes,
      lexer: {
        charClasses: {
          keyStart: {
            union: [{ predefined: "letter" }, { chars: "_-" }]
          },
          keyPart: {
            union: [{ predefined: "alphanumeric" }, { chars: "_-." }]
          }
        },
        tokenTypes: {
          comment: { category: "comment" },
          key: { category: "identifier", subcategory: "key" },
          string: { category: "string" },
          number: { category: "number" },
          constant: { category: "constant" },
          indicator: { category: "punctuation" },
          indent: { category: "whitespace" },
          dedent: { category: "whitespace" },
          whitespace: { category: "whitespace" },
          newline: { category: "newline" },
          text: { category: "plain" }
        },
        initialState: "default",
        skipTokens: ["whitespace", "newline", "indent", "dedent"],
        indentation: {
          indentToken: "indent",
          dedentToken: "dedent",
          unit: "spaces",
          size: 2
        },
        states: {
          default: {
            rules: [
              { match: { kind: "line", start: "#" }, token: "comment" },
              { match: { kind: "string", value: ["---", "...", "-", ":", "?", "|"] }, token: "indicator" },
              {
                match: { kind: "delimited", open: '"', close: '"', escape: "\\" },
                token: "string"
              },
              {
                match: { kind: "delimited", open: "'", close: "'", escape: "\\" },
                token: "string"
              },
              {
                match: {
                  kind: "number",
                  integer: true,
                  float: true,
                  scientific: true
                },
                token: "number"
              },
              {
                match: {
                  kind: "keywords",
                  words: ["true", "false", "null", "yes", "no", "on", "off"]
                },
                token: "constant"
              },
              {
                match: {
                  kind: "charSequence",
                  first: { ref: "keyStart" },
                  rest: { ref: "keyPart" }
                },
                token: "key"
              },
              {
                match: {
                  kind: "charSequence",
                  first: { predefined: "whitespace" },
                  rest: { predefined: "whitespace" }
                },
                token: "whitespace"
              },
              {
                match: { kind: "charSequence", first: { predefined: "newline" } },
                token: "newline"
              },
              {
                match: {
                  kind: "charSequence",
                  first: { predefined: "any" },
                  rest: { negate: { predefined: "newline" } }
                },
                token: "text"
              }
            ]
          }
        }
      },
      structure: {
        blocks: [],
        symbols: []
      }
    };
  }
  var yaml = createYamlProfile(
    "yaml",
    "YAML",
    [".yaml", ".yml"],
    ["application/x-yaml", "text/yaml"]
  );
  var xml = createMarkupProfile({
    name: "xml",
    displayName: "XML",
    fileExtensions: [".xml", ".xsd", ".xsl", ".xslt", ".svg"],
    mimeTypes: ["application/xml", "text/xml", "image/svg+xml"]
  });
  var java = createGenericCodeProfile({
    name: "java",
    displayName: "Java",
    fileExtensions: [".java"],
    mimeTypes: ["text/x-java-source", "text/java"],
    lineComment: "//",
    blockComment: { open: "/*", close: "*/" },
    keywords: [
      "abstract",
      "assert",
      "boolean",
      "break",
      "byte",
      "case",
      "catch",
      "char",
      "class",
      "const",
      "continue",
      "default",
      "do",
      "double",
      "else",
      "enum",
      "extends",
      "final",
      "finally",
      "float",
      "for",
      "if",
      "implements",
      "import",
      "instanceof",
      "int",
      "interface",
      "long",
      "native",
      "new",
      "package",
      "private",
      "protected",
      "public",
      "return",
      "short",
      "static",
      "strictfp",
      "super",
      "switch",
      "synchronized",
      "this",
      "throw",
      "throws",
      "transient",
      "try",
      "void",
      "volatile",
      "while"
    ]
  });
  var csharp = createGenericCodeProfile({
    name: "csharp",
    displayName: "C#",
    fileExtensions: [".cs", ".csx"],
    mimeTypes: ["text/x-csharp"],
    lineComment: "//",
    blockComment: { open: "/*", close: "*/" },
    stringDelimiters: ['"', "'", "`"],
    keywords: [
      "abstract",
      "as",
      "base",
      "bool",
      "break",
      "byte",
      "case",
      "catch",
      "char",
      "checked",
      "class",
      "const",
      "continue",
      "decimal",
      "default",
      "delegate",
      "do",
      "double",
      "else",
      "enum",
      "event",
      "explicit",
      "extern",
      "false",
      "finally",
      "fixed",
      "float",
      "for",
      "foreach",
      "goto",
      "if",
      "implicit",
      "in",
      "int",
      "interface",
      "internal",
      "is",
      "lock",
      "long",
      "namespace",
      "new",
      "null",
      "object",
      "operator",
      "out",
      "override",
      "params",
      "private",
      "protected",
      "public",
      "readonly",
      "ref",
      "return",
      "sbyte",
      "sealed",
      "short",
      "sizeof",
      "stackalloc",
      "static",
      "string",
      "struct",
      "switch",
      "this",
      "throw",
      "true",
      "try",
      "typeof",
      "uint",
      "ulong",
      "unchecked",
      "unsafe",
      "ushort",
      "using",
      "virtual",
      "void",
      "volatile",
      "while"
    ]
  });
  var rust = createGenericCodeProfile({
    name: "rust",
    displayName: "Rust",
    fileExtensions: [".rs"],
    mimeTypes: ["text/rust"],
    lineComment: "//",
    blockComment: { open: "/*", close: "*/", nested: true },
    keywords: [
      "as",
      "break",
      "const",
      "continue",
      "crate",
      "else",
      "enum",
      "extern",
      "false",
      "fn",
      "for",
      "if",
      "impl",
      "in",
      "let",
      "loop",
      "match",
      "mod",
      "move",
      "mut",
      "pub",
      "ref",
      "return",
      "self",
      "Self",
      "static",
      "struct",
      "super",
      "trait",
      "true",
      "type",
      "unsafe",
      "use",
      "where",
      "while",
      "async",
      "await",
      "dyn"
    ]
  });
  var ruby = createGenericCodeProfile({
    name: "ruby",
    displayName: "Ruby",
    fileExtensions: [".rb", ".rake", ".gemspec"],
    mimeTypes: ["application/x-ruby"],
    lineComment: "#",
    keywords: [
      "BEGIN",
      "END",
      "alias",
      "and",
      "begin",
      "break",
      "case",
      "class",
      "def",
      "defined?",
      "do",
      "else",
      "elsif",
      "end",
      "ensure",
      "false",
      "for",
      "if",
      "in",
      "module",
      "next",
      "nil",
      "not",
      "or",
      "redo",
      "rescue",
      "retry",
      "return",
      "self",
      "super",
      "then",
      "true",
      "undef",
      "unless",
      "until",
      "when",
      "while",
      "yield"
    ]
  });
  var php = createGenericCodeProfile({
    name: "php",
    displayName: "PHP",
    fileExtensions: [".php", ".phtml", ".php8"],
    mimeTypes: ["application/x-httpd-php"],
    lineComment: "//",
    blockComment: { open: "/*", close: "*/" },
    keywords: [
      "abstract",
      "and",
      "array",
      "as",
      "break",
      "callable",
      "case",
      "catch",
      "class",
      "clone",
      "const",
      "continue",
      "declare",
      "default",
      "do",
      "echo",
      "else",
      "elseif",
      "empty",
      "enddeclare",
      "endfor",
      "endforeach",
      "endif",
      "endswitch",
      "endwhile",
      "eval",
      "exit",
      "extends",
      "final",
      "finally",
      "fn",
      "for",
      "foreach",
      "function",
      "global",
      "goto",
      "if",
      "implements",
      "include",
      "include_once",
      "instanceof",
      "insteadof",
      "interface",
      "isset",
      "list",
      "match",
      "namespace",
      "new",
      "or",
      "print",
      "private",
      "protected",
      "public",
      "readonly",
      "require",
      "require_once",
      "return",
      "static",
      "switch",
      "throw",
      "trait",
      "try",
      "unset",
      "use",
      "var",
      "while",
      "xor",
      "yield"
    ]
  });
  var kotlin = createGenericCodeProfile({
    name: "kotlin",
    displayName: "Kotlin",
    fileExtensions: [".kt", ".kts"],
    mimeTypes: ["text/x-kotlin"],
    lineComment: "//",
    blockComment: { open: "/*", close: "*/" },
    keywords: [
      "as",
      "as?",
      "break",
      "class",
      "continue",
      "do",
      "else",
      "false",
      "for",
      "fun",
      "if",
      "in",
      "interface",
      "is",
      "null",
      "object",
      "package",
      "return",
      "super",
      "this",
      "throw",
      "true",
      "try",
      "typealias",
      "val",
      "var",
      "when",
      "while",
      "by",
      "catch",
      "constructor",
      "delegate",
      "dynamic",
      "field",
      "file",
      "finally",
      "get",
      "import",
      "init",
      "param",
      "property",
      "receiver",
      "set",
      "setparam",
      "where"
    ]
  });
  var swift = createGenericCodeProfile({
    name: "swift",
    displayName: "Swift",
    fileExtensions: [".swift"],
    mimeTypes: ["text/x-swift"],
    lineComment: "//",
    blockComment: { open: "/*", close: "*/", nested: true },
    keywords: [
      "associatedtype",
      "class",
      "deinit",
      "enum",
      "extension",
      "func",
      "import",
      "init",
      "inout",
      "internal",
      "let",
      "operator",
      "private",
      "protocol",
      "public",
      "static",
      "struct",
      "subscript",
      "typealias",
      "var",
      "break",
      "case",
      "continue",
      "default",
      "defer",
      "do",
      "else",
      "fallthrough",
      "for",
      "guard",
      "if",
      "in",
      "repeat",
      "return",
      "switch",
      "where",
      "while",
      "as",
      "Any",
      "catch",
      "false",
      "is",
      "nil",
      "rethrows",
      "super",
      "self",
      "Self",
      "throw",
      "throws",
      "true",
      "try"
    ]
  });
  var shell = createGenericCodeProfile({
    name: "shell",
    displayName: "Shell",
    fileExtensions: [".sh", ".bash", ".zsh", ".ksh"],
    mimeTypes: ["application/x-sh"],
    lineComment: "#",
    keywords: [
      "if",
      "then",
      "else",
      "elif",
      "fi",
      "for",
      "while",
      "until",
      "do",
      "done",
      "case",
      "esac",
      "in",
      "function",
      "select",
      "time",
      "coproc",
      "return",
      "break",
      "continue",
      "readonly",
      "local",
      "export"
    ]
  });
  var sql = createGenericCodeProfile({
    name: "sql",
    displayName: "SQL",
    fileExtensions: [".sql"],
    mimeTypes: ["application/sql", "text/x-sql"],
    lineComment: "--",
    blockComment: { open: "/*", close: "*/" },
    keywords: [
      "select",
      "from",
      "where",
      "insert",
      "into",
      "update",
      "delete",
      "create",
      "alter",
      "drop",
      "table",
      "view",
      "index",
      "join",
      "left",
      "right",
      "inner",
      "outer",
      "on",
      "group",
      "by",
      "order",
      "having",
      "limit",
      "offset",
      "union",
      "all",
      "distinct",
      "as",
      "and",
      "or",
      "not",
      "null",
      "is",
      "in",
      "exists",
      "between",
      "like",
      "case",
      "when",
      "then",
      "else",
      "end",
      "primary",
      "key",
      "foreign",
      "references",
      "constraint",
      "values",
      "set",
      "begin",
      "commit",
      "rollback"
    ]
  });
  var toml = {
    name: "toml",
    displayName: "TOML",
    version: "1.0.0",
    fileExtensions: [".toml"],
    mimeTypes: ["application/toml", "text/toml"],
    lexer: {
      charClasses: {
        keyStart: {
          union: [{ predefined: "letter" }, { chars: "_-" }]
        },
        keyPart: {
          union: [{ predefined: "alphanumeric" }, { chars: "_-" }]
        }
      },
      tokenTypes: {
        comment: { category: "comment" },
        datetime: { category: "string", subcategory: "datetime" },
        key: { category: "identifier", subcategory: "key" },
        string: { category: "string" },
        number: { category: "number" },
        constant: { category: "constant" },
        operator: { category: "operator" },
        punctuation: { category: "punctuation" },
        whitespace: { category: "whitespace" },
        newline: { category: "newline" },
        text: { category: "plain" }
      },
      initialState: "default",
      skipTokens: ["whitespace", "newline"],
      states: {
        default: {
          rules: [
            { match: { kind: "line", start: "#" }, token: "comment" },
            {
              match: {
                kind: "pattern",
                regex: "\\b\\d{4}-\\d{2}-\\d{2}(?:[Tt ]\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?)?(?:[Zz]|[+-]\\d{2}:\\d{2})?\\b"
              },
              token: "datetime"
            },
            {
              match: { kind: "delimited", open: '"""', close: '"""', multiline: true, escape: "\\" },
              token: "string"
            },
            {
              match: { kind: "delimited", open: "'''", close: "'''", multiline: true },
              token: "string"
            },
            {
              match: { kind: "delimited", open: '"', close: '"', escape: "\\" },
              token: "string"
            },
            {
              match: { kind: "delimited", open: "'", close: "'" },
              token: "string"
            },
            {
              match: {
                kind: "number",
                integer: true,
                float: true,
                scientific: true,
                hex: true,
                octal: true,
                binary: true,
                separator: "_"
              },
              token: "number"
            },
            {
              match: {
                kind: "keywords",
                words: ["true", "false"]
              },
              token: "constant"
            },
            {
              match: {
                kind: "charSequence",
                first: { ref: "keyStart" },
                rest: {
                  union: [{ ref: "keyPart" }, { chars: "." }]
                }
              },
              token: "key"
            },
            {
              match: { kind: "string", value: "=" },
              token: "operator"
            },
            {
              match: { kind: "string", value: ["[[", "]]", "[", "]", "{", "}", ","] },
              token: "punctuation"
            },
            {
              match: {
                kind: "charSequence",
                first: { predefined: "whitespace" },
                rest: { predefined: "whitespace" }
              },
              token: "whitespace"
            },
            {
              match: { kind: "charSequence", first: { predefined: "newline" } },
              token: "newline"
            },
            {
              match: {
                kind: "charSequence",
                first: { predefined: "any" },
                rest: { negate: { predefined: "newline" } }
              },
              token: "text"
            }
          ]
        }
      }
    },
    structure: {
      blocks: [
        { name: "tables", open: "[", close: "]" },
        { name: "inline-table", open: "{", close: "}" },
        { name: "array", open: "[", close: "]" }
      ],
      symbols: [
        {
          name: "table",
          kind: "namespace",
          pattern: [
            { token: "punctuation", value: "[" },
            { token: "key", capture: "name" },
            { token: "punctuation", value: "]" }
          ],
          hasBody: false
        },
        {
          name: "array_table",
          kind: "namespace",
          pattern: [
            { token: "punctuation", value: "[[" },
            { token: "key", capture: "name" },
            { token: "punctuation", value: "]]" }
          ],
          hasBody: false
        }
      ]
    }
  };
  var builtinProfiles = [
    json,
    css,
    scss,
    python,
    go,
    javascript,
    typescript,
    cpp,
    html,
    markdown,
    yaml,
    xml,
    java,
    csharp,
    rust,
    ruby,
    php,
    kotlin,
    swift,
    shell,
    sql,
    toml
  ];
  var profilesByName = /* @__PURE__ */ new Map();
  var profilesByExtension = /* @__PURE__ */ new Map();
  function registerProfile(profile) {
    profilesByName.set(profile.name, profile);
    for (const ext of profile.fileExtensions) {
      profilesByExtension.set(ext.toLowerCase(), profile);
    }
  }
  function getProfile(nameOrExt) {
    var _a;
    return (_a = profilesByName.get(nameOrExt)) != null ? _a : profilesByExtension.get(nameOrExt.toLowerCase());
  }
  for (const profile of builtinProfiles) {
    registerProfile(profile);
  }
  function tokenize(source, language) {
    const profile = resolveLanguage(language);
    return tokenizeWithConfig(source, profile.lexer);
  }
  function extractSymbols(source, language) {
    const profile = resolveLanguage(language);
    return extractSymbolsFromProfile(source, profile);
  }
  function resolveLanguage(language) {
    const profile = getProfile(language);
    if (!profile) {
      throw new Error(
        `Unknown language: "${language}". Use getRegisteredLanguages() to see available languages.`
      );
    }
    return profile;
  }

  // src/decorations/splitter.ts
  function splitTokensAtRanges(tokens, ranges) {
    if (ranges.length === 0) return tokens;
    const boundarySet = /* @__PURE__ */ new Set();
    for (const range of ranges) {
      boundarySet.add(range.start.offset);
      boundarySet.add(range.end.offset);
    }
    const boundaries = Array.from(boundarySet).sort((a, b) => a - b);
    if (boundaries.length === 0) return tokens;
    const result = [];
    for (const token of tokens) {
      const tokenStart = token.range.start.offset;
      const tokenEnd = token.range.end.offset;
      const splitPoints = [];
      for (const b of boundaries) {
        if (b > tokenStart && b < tokenEnd) {
          splitPoints.push(b);
        }
      }
      if (splitPoints.length === 0) {
        result.push(token);
        continue;
      }
      const cuts = [tokenStart, ...splitPoints, tokenEnd];
      for (let i = 0; i < cuts.length - 1; i++) {
        const sliceStart = cuts[i] - tokenStart;
        const sliceEnd = cuts[i + 1] - tokenStart;
        const value = token.value.substring(sliceStart, sliceEnd);
        if (value.length === 0) continue;
        const startPos = computePosition(token, sliceStart);
        const endPos = computePosition(token, sliceEnd);
        result.push({
          type: token.type,
          value,
          category: token.category,
          range: { start: startPos, end: endPos }
        });
      }
    }
    return result;
  }
  function computePosition(token, charOffset) {
    const baseOffset = token.range.start.offset;
    const baseLine = token.range.start.line;
    const baseColumn = token.range.start.column;
    const text = token.value.substring(0, charOffset);
    let line = baseLine;
    let column = baseColumn;
    for (let i = 0; i < text.length; i++) {
      if (text[i] === "\n") {
        line++;
        column = 0;
      } else if (text[i] === "\r") {
        line++;
        column = 0;
        if (i + 1 < text.length && text[i + 1] === "\n") {
          i++;
        }
      } else {
        column++;
      }
    }
    return { line, column, offset: baseOffset + charOffset };
  }

  // src/decorations/decorator.ts
  function applyDecorations(tokens, decorations) {
    if (decorations.length === 0) {
      return tokens.map((token) => ({ token, extraClasses: [], extraAttrs: {} }));
    }
    const sorted = [...decorations].sort(
      (a, b) => {
        var _a, _b;
        return ((_a = a.priority) != null ? _a : 0) - ((_b = b.priority) != null ? _b : 0);
      }
    );
    const ranges = sorted.map((d) => d.range);
    const splitTokens = splitTokensAtRanges(tokens, ranges);
    return splitTokens.map((token) => {
      const extraClasses = [];
      const extraAttrs = {};
      const styles = [];
      for (const decoration of sorted) {
        if (rangeContains(decoration.range, token.range)) {
          if (decoration.className) {
            extraClasses.push(decoration.className);
          }
          if (decoration.style) {
            styles.push(decoration.style);
          }
          if (decoration.data) {
            Object.assign(extraAttrs, decoration.data);
          }
        }
      }
      return {
        token,
        extraClasses,
        extraAttrs,
        extraStyle: styles.length > 0 ? styles.join(";") : void 0
      };
    });
  }
  function rangeContains(outer, inner) {
    return outer.start.offset <= inner.start.offset && outer.end.offset >= inner.end.offset;
  }

  // src/html/escaper.ts
  var ESCAPE_MAP = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  var ESCAPE_RE = /[&<>"']/g;
  function escapeHtml(text) {
    return text.replace(ESCAPE_RE, (ch) => ESCAPE_MAP[ch]);
  }

  // src/html/renderer.ts
  function renderTokensToHtml(tokens, options = {}) {
    var _a, _b;
    const prefix = (_a = options.classPrefix) != null ? _a : "hlts-";
    const decorated = options.decorations && options.decorations.length > 0 ? applyDecorations(tokens, options.decorations) : tokens.map((token) => ({ token, extraClasses: [], extraAttrs: {} }));
    const parts = [];
    for (const { token, extraClasses, extraAttrs, extraStyle } of decorated) {
      if (token.category === "whitespace" || token.category === "newline") {
        parts.push(token.value);
        continue;
      }
      const escaped = escapeHtml(token.value);
      if (options.theme) {
        const baseStyle = (_b = options.theme.styles[token.category]) != null ? _b : "";
        const combinedStyle = extraStyle ? `${baseStyle};${extraStyle}` : baseStyle;
        const attrs = formatDataAttrs(extraAttrs);
        parts.push(`<span style="${combinedStyle}"${attrs}>${escaped}</span>`);
      } else {
        const classes = [prefix + token.category, ...extraClasses].join(" ");
        const attrs = formatDataAttrs(extraAttrs);
        parts.push(`<span class="${classes}"${attrs}>${escaped}</span>`);
      }
    }
    return parts.join("");
  }
  function formatDataAttrs(attrs) {
    const entries = Object.entries(attrs);
    if (entries.length === 0) return "";
    return entries.map(([k, v]) => ` data-${k}="${escapeHtml(v)}"`).join("");
  }

  // src/html/diff-renderer.ts
  function renderDiffToHtml(diff, options = {}) {
    var _a, _b;
    const view = (_a = options.view) != null ? _a : "side-by-side";
    const prefix = (_b = options.classPrefix) != null ? _b : "hlts-";
    if (view === "inline") {
      return renderInlineDiff(diff, options, prefix);
    }
    return renderSideBySideDiff(diff, options, prefix);
  }
  function renderSideBySideDiff(diff, options, prefix) {
    var _a;
    const { model } = diff;
    const showHeader = (_a = options.showHeader) != null ? _a : true;
    const rows = [];
    if (showHeader) {
      rows.push(
        `<tr class="${prefix}diff-header"><th class="${prefix}diff-label" colspan="2">${escapeHtml(model.oldLabel)}</th><th class="${prefix}diff-label" colspan="2">${escapeHtml(model.newLabel)}</th></tr>`
      );
    }
    for (const row of model.rows) {
      const className = `${prefix}diff-row ${prefix}diff-${row.changeType}`;
      const oldContent = renderLineContent(
        row.oldLineNumber,
        diff.oldLineTokens,
        options,
        row.oldText
      );
      const newContent = renderLineContent(
        row.newLineNumber,
        diff.newLineTokens,
        options,
        row.newText
      );
      rows.push(
        `<tr class="${className}"><td class="${prefix}diff-gutter">${formatLineNumber(row.oldLineNumber)}</td><td class="${prefix}diff-content">${oldContent}</td><td class="${prefix}diff-gutter">${formatLineNumber(row.newLineNumber)}</td><td class="${prefix}diff-content">${newContent}</td></tr>`
      );
    }
    return `<table class="${prefix}diff ${prefix}diff-side-by-side"><tbody>${rows.join("")}</tbody></table>`;
  }
  function renderInlineDiff(diff, options, prefix) {
    const rows = [];
    for (const row of diff.model.rows) {
      if (row.changeType === "context") {
        rows.push(
          `<tr class="${prefix}diff-row ${prefix}diff-context"><td class="${prefix}diff-gutter">${formatLineNumber(row.newLineNumber)}</td><td class="${prefix}diff-sign"> </td><td class="${prefix}diff-content">${renderLineContent(
            row.newLineNumber,
            diff.newLineTokens,
            options,
            row.newText
          )}</td></tr>`
        );
        continue;
      }
      if (row.oldLineNumber !== null) {
        rows.push(
          `<tr class="${prefix}diff-row ${prefix}diff-removed"><td class="${prefix}diff-gutter">${formatLineNumber(row.oldLineNumber)}</td><td class="${prefix}diff-sign">-</td><td class="${prefix}diff-content">${renderLineContent(
            row.oldLineNumber,
            diff.oldLineTokens,
            options,
            row.oldText
          )}</td></tr>`
        );
      }
      if (row.newLineNumber !== null) {
        rows.push(
          `<tr class="${prefix}diff-row ${prefix}diff-added"><td class="${prefix}diff-gutter">${formatLineNumber(row.newLineNumber)}</td><td class="${prefix}diff-sign">+</td><td class="${prefix}diff-content">${renderLineContent(
            row.newLineNumber,
            diff.newLineTokens,
            options,
            row.newText
          )}</td></tr>`
        );
      }
    }
    return `<table class="${prefix}diff ${prefix}diff-inline"><tbody>${rows.join("")}</tbody></table>`;
  }
  function renderLineContent(lineNumber, tokenMap, options, fallbackText) {
    if (lineNumber === null) return "";
    const tokens = tokenMap.get(lineNumber);
    if (!tokens || tokens.length === 0) {
      return escapeHtml(fallbackText);
    }
    return renderTokensToHtml(tokens, {
      classPrefix: options.classPrefix,
      theme: options.theme,
      decorations: options.decorations
    });
  }
  function formatLineNumber(lineNumber) {
    return lineNumber === null ? "" : String(lineNumber);
  }

  // src/html/line-wrapper.ts
  function groupTokensByLine(tokens) {
    var _a;
    const lineMap = /* @__PURE__ */ new Map();
    for (const token of tokens) {
      const fragments = splitTokenAtNewlines(token);
      for (const fragment of fragments) {
        const line = fragment.range.start.line;
        let group = lineMap.get(line);
        if (!group) {
          group = [];
          lineMap.set(line, group);
        }
        group.push(fragment);
      }
    }
    const lineNumbers = Array.from(lineMap.keys()).sort((a, b) => a - b);
    if (lineNumbers.length === 0) return [];
    const firstLine = lineNumbers[0];
    const lastLine = lineNumbers[lineNumbers.length - 1];
    const result = [];
    for (let line = firstLine; line <= lastLine; line++) {
      result.push({
        lineNumber: line,
        tokens: (_a = lineMap.get(line)) != null ? _a : []
      });
    }
    return result;
  }
  function splitTokenAtNewlines(token) {
    const { value } = token;
    if (!value.includes("\n") && !value.includes("\r")) {
      return [token];
    }
    const fragments = [];
    let currentOffset = token.range.start.offset;
    let currentLine = token.range.start.line;
    let currentColumn = token.range.start.column;
    let segmentStart = 0;
    for (let i = 0; i <= value.length; i++) {
      const ch = value[i];
      const isEnd = i === value.length;
      const isNewline = ch === "\n" || ch === "\r";
      if (isNewline || isEnd) {
        let segmentEnd = i;
        if (isNewline) {
          segmentEnd = i + 1;
          if (ch === "\r" && i + 1 < value.length && value[i + 1] === "\n") {
            segmentEnd = i + 2;
          }
        }
        if (segmentEnd > segmentStart) {
          const segmentValue = value.substring(segmentStart, segmentEnd);
          const startPos = {
            line: currentLine,
            column: currentColumn,
            offset: currentOffset
          };
          const endPos = {
            line: isNewline ? currentLine : currentLine,
            column: isNewline ? currentColumn + (segmentEnd - segmentStart) : currentColumn + (segmentEnd - segmentStart),
            offset: currentOffset + (segmentEnd - segmentStart)
          };
          fragments.push({
            type: token.type,
            value: segmentValue,
            category: token.category,
            range: { start: startPos, end: endPos }
          });
          currentOffset += segmentEnd - segmentStart;
        }
        if (isNewline) {
          currentLine++;
          currentColumn = 0;
          segmentStart = segmentEnd;
          if (ch === "\r" && i + 1 < value.length && value[i + 1] === "\n") {
            i++;
          }
        }
      }
    }
    return fragments.length > 0 ? fragments : [token];
  }
  function wrapInLines(tokens, renderLine, options = {}) {
    var _a, _b;
    const startLine = (_a = options.startLine) != null ? _a : 1;
    const dataAttrs = (_b = options.dataLineAttributes) != null ? _b : true;
    const groups = groupTokensByLine(tokens);
    if (groups.length === 0) {
      return '<table class="hlts-table"><tbody></tbody></table>';
    }
    const rows = [];
    for (const group of groups) {
      const displayLine = group.lineNumber - groups[0].lineNumber + startLine;
      const lineContent = renderLine(group.tokens);
      const dataAttr = dataAttrs ? ` data-line="${displayLine}"` : "";
      rows.push(
        `<tr${dataAttr}><td class="hlts-line-number">${displayLine}</td><td class="hlts-line-content">${lineContent}</td></tr>`
      );
    }
    return `<table class="hlts-table"><tbody>${rows.join("")}</tbody></table>`;
  }

  // src/ansi/codes.ts
  var ESC = "\x1B[";
  var RESET = `${ESC}0m`;

  // src/semantic/enhancer.ts
  var TYPE_KEYWORDS = /* @__PURE__ */ new Set([
    "class",
    "interface",
    "type",
    "enum",
    "struct",
    "trait",
    "namespace",
    "module"
  ]);
  var VARIABLE_DECL_KEYWORDS = /* @__PURE__ */ new Set([
    "const",
    "let",
    "var",
    "val",
    "final"
  ]);
  var FUNCTION_DECL_KEYWORDS = /* @__PURE__ */ new Set([
    "function",
    "def",
    "fn"
  ]);
  var CONSTANT_LITERALS = /* @__PURE__ */ new Set([
    "true",
    "false",
    "null",
    "undefined",
    "None",
    "nil"
  ]);
  var PRIMITIVE_TYPE_NAMES = /* @__PURE__ */ new Set([
    "string",
    "number",
    "boolean",
    "object",
    "void",
    "never",
    "unknown",
    "any",
    "int",
    "float",
    "double",
    "char",
    "str",
    "bytes"
  ]);
  var BUILTIN_TYPE_LIKE_NAMES = /* @__PURE__ */ new Set([
    "Array",
    "Map",
    "Set",
    "Date",
    "Promise",
    "Error",
    "RegExp",
    "Math",
    "JSON",
    "console"
  ]);
  var isAlphaNumOrUnderscore = /^[A-Za-z0-9_]+$/;
  var isUpperSnakeCase = /^[A-Z][A-Z0-9_]*$/;
  var isPascalCase = /^[A-Z][A-Za-z0-9_]*$/;
  function enhanceTokenSemantics(tokens) {
    const indexed = tokens.map((token, index) => ({ token, index })).filter(({ token }) => token.category !== "whitespace" && token.category !== "newline");
    if (indexed.length === 0) return tokens;
    const categoryOverrides = /* @__PURE__ */ new Map();
    for (let i = 0; i < indexed.length; i++) {
      const current = indexed[i];
      const prev = i > 0 ? indexed[i - 1] : void 0;
      const next = i + 1 < indexed.length ? indexed[i + 1] : void 0;
      const next2 = i + 2 < indexed.length ? indexed[i + 2] : void 0;
      applyConstantLiteralHeuristic(current, categoryOverrides);
      applyIdentifierHeuristics(current, prev, next, next2, categoryOverrides);
    }
    if (categoryOverrides.size === 0) return tokens;
    return tokens.map((token, index) => {
      const override = categoryOverrides.get(index);
      if (!override || override === token.category) return token;
      return { ...token, category: override };
    });
  }
  function applyConstantLiteralHeuristic(current, overrides) {
    const { token, index } = current;
    if (token.category !== "identifier") return;
    if (CONSTANT_LITERALS.has(token.value)) {
      overrides.set(index, "constant");
    }
  }
  function applyIdentifierHeuristics(current, prev, next, next2, overrides) {
    const { token, index } = current;
    if (token.category !== "identifier") return;
    if (!isAlphaNumOrUnderscore.test(token.value)) return;
    if ((prev == null ? void 0 : prev.token.value) === ".") {
      overrides.set(index, "attribute");
      return;
    }
    if (isUpperSnakeCase.test(token.value)) {
      overrides.set(index, "constant");
      return;
    }
    if (PRIMITIVE_TYPE_NAMES.has(token.value) || BUILTIN_TYPE_LIKE_NAMES.has(token.value)) {
      overrides.set(index, "type");
      return;
    }
    if (isPascalCase.test(token.value)) {
      overrides.set(index, "type");
      return;
    }
    if ((prev == null ? void 0 : prev.token.category) === "keyword" && TYPE_KEYWORDS.has(prev.token.value)) {
      overrides.set(index, "type");
      return;
    }
    if ((prev == null ? void 0 : prev.token.category) === "keyword" && FUNCTION_DECL_KEYWORDS.has(prev.token.value)) {
      overrides.set(index, "variable");
      return;
    }
    if ((prev == null ? void 0 : prev.token.category) === "keyword" && VARIABLE_DECL_KEYWORDS.has(prev.token.value)) {
      overrides.set(index, "variable");
      return;
    }
    if ((next == null ? void 0 : next.token.value) === "=" && (prev == null ? void 0 : prev.token.value) !== ".") {
      overrides.set(index, "attribute");
      return;
    }
    if ((prev == null ? void 0 : prev.token.value) === "(" && (next == null ? void 0 : next.token.value) === ")" && (next2 == null ? void 0 : next2.token.value) === "=>") {
      overrides.set(index, "variable");
      return;
    }
    if ((next == null ? void 0 : next.token.value) === "(") {
      overrides.set(index, "variable");
      return;
    }
  }

  // src/diff/model.ts
  function createDiffModel(oldSource, newSource, options = {}) {
    var _a, _b;
    const oldLines = splitLines(oldSource);
    const newLines = splitLines(newSource);
    const pairs = alignLinePairs(oldLines, newLines);
    const rows = pairs.map((pair) => {
      const { oldLineNumber, newLineNumber, oldText, newText } = pair;
      let changeType = "context";
      if (oldLineNumber === null) {
        changeType = "added";
      } else if (newLineNumber === null) {
        changeType = "removed";
      } else if (oldText !== newText) {
        changeType = "modified";
      }
      return {
        changeType,
        oldLineNumber,
        newLineNumber,
        oldText,
        newText
      };
    });
    return {
      oldLabel: (_a = options.oldLabel) != null ? _a : "Original",
      newLabel: (_b = options.newLabel) != null ? _b : "Updated",
      rows
    };
  }
  function createDiffModelWithTokens(oldSource, newSource, language, options = {}) {
    const model = createDiffModel(oldSource, newSource, options);
    const oldLineTokens = tokenizeSourceByLine(oldSource, language, options);
    const newLineTokens = tokenizeSourceByLine(newSource, language, options);
    return {
      model,
      oldLineTokens,
      newLineTokens
    };
  }
  function tokenizeSourceByLine(source, language, options) {
    const rawTokens = tokenize(source, language);
    const tokens = options.semanticHighlighting ? enhanceTokenSemantics(rawTokens) : rawTokens;
    const grouped = groupTokensByLine(tokens);
    const map = /* @__PURE__ */ new Map();
    for (const group of grouped) {
      map.set(group.lineNumber, group.tokens);
    }
    return map;
  }
  function splitLines(source) {
    const normalized = source.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    return normalized.split("\n");
  }
  function alignLinePairs(oldLines, newLines) {
    const ops = buildLineOps(oldLines, newLines);
    const rows = [];
    let index = 0;
    while (index < ops.length) {
      const op = ops[index];
      if (op.kind === "equal") {
        rows.push({
          oldLineNumber: op.oldIndex + 1,
          newLineNumber: op.newIndex + 1,
          oldText: oldLines[op.oldIndex],
          newText: newLines[op.newIndex]
        });
        index++;
        continue;
      }
      const deleted = [];
      const added = [];
      while (index < ops.length && ops[index].kind === "delete") {
        deleted.push(ops[index].oldIndex);
        index++;
      }
      while (index < ops.length && ops[index].kind === "add") {
        added.push(ops[index].newIndex);
        index++;
      }
      if (deleted.length === 0 && added.length === 0) {
        continue;
      }
      const width = Math.max(deleted.length, added.length);
      for (let i = 0; i < width; i++) {
        const oldIndex = deleted[i];
        const newIndex = added[i];
        rows.push({
          oldLineNumber: oldIndex === void 0 ? null : oldIndex + 1,
          newLineNumber: newIndex === void 0 ? null : newIndex + 1,
          oldText: oldIndex === void 0 ? "" : oldLines[oldIndex],
          newText: newIndex === void 0 ? "" : newLines[newIndex]
        });
      }
    }
    return rows;
  }
  function buildLineOps(oldLines, newLines) {
    const m = oldLines.length;
    const n = newLines.length;
    const dp = Array.from(
      { length: m + 1 },
      () => Array(n + 1).fill(0)
    );
    for (let i2 = m - 1; i2 >= 0; i2--) {
      for (let j2 = n - 1; j2 >= 0; j2--) {
        if (oldLines[i2] === newLines[j2]) {
          dp[i2][j2] = dp[i2 + 1][j2 + 1] + 1;
        } else {
          dp[i2][j2] = Math.max(dp[i2 + 1][j2], dp[i2][j2 + 1]);
        }
      }
    }
    const ops = [];
    let i = 0;
    let j = 0;
    while (i < m && j < n) {
      if (oldLines[i] === newLines[j]) {
        ops.push({ kind: "equal", oldIndex: i, newIndex: j });
        i++;
        j++;
        continue;
      }
      if (dp[i + 1][j] >= dp[i][j + 1]) {
        ops.push({ kind: "delete", oldIndex: i });
        i++;
      } else {
        ops.push({ kind: "add", newIndex: j });
        j++;
      }
    }
    while (i < m) {
      ops.push({ kind: "delete", oldIndex: i });
      i++;
    }
    while (j < n) {
      ops.push({ kind: "add", newIndex: j });
      j++;
    }
    return ops;
  }

  // src/themes/default-light.ts
  var defaultLightTheme = {
    name: "default-light",
    background: "#fafafa",
    foreground: "#383a42",
    lineNumberColor: "#a0a1a7",
    lineNumberBorderColor: "#e0e0e0",
    styles: {
      keyword: "color:#a626a4;font-weight:bold",
      identifier: "color:#383a42",
      string: "color:#50a14f",
      number: "color:#986801",
      comment: "color:#a0a1a7;font-style:italic",
      operator: "color:#383a42",
      punctuation: "color:#383a42",
      type: "color:#c18401",
      decorator: "color:#a626a4",
      tag: "color:#e45649",
      attribute: "color:#986801",
      meta: "color:#a0a1a7",
      regexp: "color:#50a14f",
      escape: "color:#986801;font-weight:bold",
      variable: "color:#e45649",
      constant: "color:#986801",
      error: "color:#e45649;text-decoration:wavy underline",
      plain: "color:#383a42"
    }
  };

  // src/themes/default-dark.ts
  var defaultDarkTheme = {
    name: "default-dark",
    background: "#282c34",
    foreground: "#abb2bf",
    lineNumberColor: "#636d83",
    lineNumberBorderColor: "#3b4048",
    styles: {
      keyword: "color:#c678dd;font-weight:bold",
      identifier: "color:#abb2bf",
      string: "color:#98c379",
      number: "color:#d19a66",
      comment: "color:#5c6370;font-style:italic",
      operator: "color:#abb2bf",
      punctuation: "color:#abb2bf",
      type: "color:#e5c07b",
      decorator: "color:#c678dd",
      tag: "color:#e06c75",
      attribute: "color:#d19a66",
      meta: "color:#5c6370",
      regexp: "color:#98c379",
      escape: "color:#d19a66;font-weight:bold",
      variable: "color:#e06c75",
      constant: "color:#d19a66",
      error: "color:#e06c75;text-decoration:wavy underline",
      plain: "color:#abb2bf"
    }
  };

  // src/themes/github-light.ts
  var githubLightTheme = {
    name: "github-light",
    background: "#ffffff",
    foreground: "#1f2328",
    lineNumberColor: "#8c959f",
    lineNumberBorderColor: "#d1d9e0",
    styles: {
      keyword: "color:#cf222e;font-weight:bold",
      identifier: "color:#1f2328",
      string: "color:#0a3069",
      number: "color:#0550ae",
      comment: "color:#6e7781;font-style:italic",
      operator: "color:#1f2328",
      punctuation: "color:#1f2328",
      type: "color:#953800",
      decorator: "color:#8250df",
      tag: "color:#116329",
      attribute: "color:#0550ae",
      meta: "color:#6e7781",
      regexp: "color:#0a3069",
      escape: "color:#0550ae;font-weight:bold",
      variable: "color:#953800",
      constant: "color:#0550ae",
      error: "color:#cf222e;text-decoration:wavy underline",
      plain: "color:#1f2328"
    }
  };

  // src/themes/github-dark.ts
  var githubDarkTheme = {
    name: "github-dark",
    background: "#0d1117",
    foreground: "#e6edf3",
    lineNumberColor: "#6e7681",
    lineNumberBorderColor: "#30363d",
    styles: {
      keyword: "color:#ff7b72;font-weight:bold",
      identifier: "color:#e6edf3",
      string: "color:#a5d6ff",
      number: "color:#79c0ff",
      comment: "color:#8b949e;font-style:italic",
      operator: "color:#e6edf3",
      punctuation: "color:#e6edf3",
      type: "color:#ffa657",
      decorator: "color:#d2a8ff",
      tag: "color:#7ee787",
      attribute: "color:#79c0ff",
      meta: "color:#8b949e",
      regexp: "color:#a5d6ff",
      escape: "color:#79c0ff;font-weight:bold",
      variable: "color:#ffa657",
      constant: "color:#79c0ff",
      error: "color:#ff7b72;text-decoration:wavy underline",
      plain: "color:#e6edf3"
    }
  };

  // src/themes/monokai.ts
  var monokaiTheme = {
    name: "monokai",
    background: "#272822",
    foreground: "#f8f8f2",
    lineNumberColor: "#90908a",
    lineNumberBorderColor: "#3e3d32",
    styles: {
      keyword: "color:#f92672;font-weight:bold",
      identifier: "color:#f8f8f2",
      string: "color:#e6db74",
      number: "color:#ae81ff",
      comment: "color:#75715e;font-style:italic",
      operator: "color:#f92672",
      punctuation: "color:#f8f8f2",
      type: "color:#66d9ef;font-style:italic",
      decorator: "color:#66d9ef",
      tag: "color:#f92672",
      attribute: "color:#a6e22e",
      meta: "color:#75715e",
      regexp: "color:#e6db74",
      escape: "color:#ae81ff;font-weight:bold",
      variable: "color:#fd971f",
      constant: "color:#ae81ff",
      error: "color:#f92672;text-decoration:wavy underline",
      plain: "color:#f8f8f2"
    }
  };

  // src/themes/dracula.ts
  var draculaTheme = {
    name: "dracula",
    background: "#282a36",
    foreground: "#f8f8f2",
    lineNumberColor: "#6272a4",
    lineNumberBorderColor: "#44475a",
    styles: {
      keyword: "color:#ff79c6;font-weight:bold",
      identifier: "color:#f8f8f2",
      string: "color:#f1fa8c",
      number: "color:#bd93f9",
      comment: "color:#6272a4;font-style:italic",
      operator: "color:#ff79c6",
      punctuation: "color:#f8f8f2",
      type: "color:#8be9fd;font-style:italic",
      decorator: "color:#50fa7b",
      tag: "color:#ff79c6",
      attribute: "color:#50fa7b",
      meta: "color:#6272a4",
      regexp: "color:#f1fa8c",
      escape: "color:#bd93f9;font-weight:bold",
      variable: "color:#ffb86c",
      constant: "color:#bd93f9",
      error: "color:#ff5555;text-decoration:wavy underline",
      plain: "color:#f8f8f2"
    }
  };

  // src/themes/nord.ts
  var nordTheme = {
    name: "nord",
    background: "#2e3440",
    foreground: "#d8dee9",
    lineNumberColor: "#4c566a",
    lineNumberBorderColor: "#3b4252",
    styles: {
      keyword: "color:#81a1c1;font-weight:bold",
      identifier: "color:#d8dee9",
      string: "color:#a3be8c",
      number: "color:#b48ead",
      comment: "color:#616e88;font-style:italic",
      operator: "color:#81a1c1",
      punctuation: "color:#eceff4",
      type: "color:#8fbcbb",
      decorator: "color:#d08770",
      tag: "color:#81a1c1",
      attribute: "color:#8fbcbb",
      meta: "color:#616e88",
      regexp: "color:#ebcb8b",
      escape: "color:#d08770;font-weight:bold",
      variable: "color:#d8dee9",
      constant: "color:#b48ead",
      error: "color:#bf616a;text-decoration:wavy underline",
      plain: "color:#d8dee9"
    }
  };

  // src/themes/solarized-light.ts
  var solarizedLightTheme = {
    name: "solarized-light",
    background: "#fdf6e3",
    foreground: "#657b83",
    lineNumberColor: "#93a1a1",
    lineNumberBorderColor: "#eee8d5",
    styles: {
      keyword: "color:#859900;font-weight:bold",
      identifier: "color:#657b83",
      string: "color:#2aa198",
      number: "color:#d33682",
      comment: "color:#93a1a1;font-style:italic",
      operator: "color:#657b83",
      punctuation: "color:#657b83",
      type: "color:#b58900",
      decorator: "color:#6c71c4",
      tag: "color:#268bd2",
      attribute: "color:#b58900",
      meta: "color:#93a1a1",
      regexp: "color:#dc322f",
      escape: "color:#cb4b16;font-weight:bold",
      variable: "color:#268bd2",
      constant: "color:#d33682",
      error: "color:#dc322f;text-decoration:wavy underline",
      plain: "color:#657b83"
    }
  };

  // src/themes/solarized-dark.ts
  var solarizedDarkTheme = {
    name: "solarized-dark",
    background: "#002b36",
    foreground: "#839496",
    lineNumberColor: "#586e75",
    lineNumberBorderColor: "#073642",
    styles: {
      keyword: "color:#859900;font-weight:bold",
      identifier: "color:#839496",
      string: "color:#2aa198",
      number: "color:#d33682",
      comment: "color:#586e75;font-style:italic",
      operator: "color:#839496",
      punctuation: "color:#839496",
      type: "color:#b58900",
      decorator: "color:#6c71c4",
      tag: "color:#268bd2",
      attribute: "color:#b58900",
      meta: "color:#586e75",
      regexp: "color:#dc322f",
      escape: "color:#cb4b16;font-weight:bold",
      variable: "color:#268bd2",
      constant: "color:#d33682",
      error: "color:#dc322f;text-decoration:wavy underline",
      plain: "color:#839496"
    }
  };

  // src/themes/tokyo-night.ts
  var tokyoNightTheme = {
    name: "tokyo-night",
    background: "#1a1b26",
    foreground: "#a9b1d6",
    lineNumberColor: "#3b4261",
    lineNumberBorderColor: "#292e42",
    styles: {
      keyword: "color:#9d7cd8;font-weight:bold",
      identifier: "color:#c0caf5",
      string: "color:#9ece6a",
      number: "color:#ff9e64",
      comment: "color:#565f89;font-style:italic",
      operator: "color:#89ddff",
      punctuation: "color:#a9b1d6",
      type: "color:#2ac3de",
      decorator: "color:#bb9af7",
      tag: "color:#f7768e",
      attribute: "color:#73daca",
      meta: "color:#565f89",
      regexp: "color:#b4f9f8",
      escape: "color:#ff9e64;font-weight:bold",
      variable: "color:#7dcfff",
      constant: "color:#ff9e64",
      error: "color:#f7768e;text-decoration:wavy underline",
      plain: "color:#a9b1d6"
    }
  };

  // src/themes/catppuccin-mocha.ts
  var catppuccinMochaTheme = {
    name: "catppuccin-mocha",
    background: "#1e1e2e",
    foreground: "#cdd6f4",
    lineNumberColor: "#585b70",
    lineNumberBorderColor: "#313244",
    styles: {
      keyword: "color:#cba6f7;font-weight:bold",
      identifier: "color:#cdd6f4",
      string: "color:#a6e3a1",
      number: "color:#fab387",
      comment: "color:#6c7086;font-style:italic",
      operator: "color:#89dceb",
      punctuation: "color:#9399b2",
      type: "color:#f9e2af",
      decorator: "color:#f5c2e7",
      tag: "color:#89b4fa",
      attribute: "color:#f2cdcd",
      meta: "color:#6c7086",
      regexp: "color:#f5c2e7",
      escape: "color:#fab387;font-weight:bold",
      variable: "color:#f38ba8",
      constant: "color:#fab387",
      error: "color:#f38ba8;text-decoration:wavy underline",
      plain: "color:#cdd6f4"
    }
  };

  // src/themes/index.ts
  var builtinThemes = [
    defaultLightTheme,
    defaultDarkTheme,
    githubLightTheme,
    githubDarkTheme,
    monokaiTheme,
    draculaTheme,
    nordTheme,
    solarizedLightTheme,
    solarizedDarkTheme,
    tokyoNightTheme,
    catppuccinMochaTheme
  ];

  // src/index.ts
  function highlight(source, language, options = {}) {
    const tokens = tokenize(source, language);
    return highlightTokens(tokens, options);
  }
  function highlightDiff(oldSource, newSource, language, options = {}) {
    const diff = createDiffModelWithTokens(oldSource, newSource, language, options);
    return renderDiffToHtml(diff, options);
  }
  function diffModel(oldSource, newSource, options = {}) {
    return createDiffModel(oldSource, newSource, options);
  }
  function highlightTokens(tokens, options = {}) {
    const semanticTokens = options.semanticHighlighting ? enhanceTokenSemantics(tokens) : tokens;
    const renderOpts = {
      classPrefix: options.classPrefix,
      theme: options.theme,
      decorations: options.decorations
    };
    let inner;
    if (options.lineNumbers) {
      inner = wrapInLines(
        semanticTokens,
        (lineTokens) => renderTokensToHtml(lineTokens, renderOpts),
        {
          startLine: options.startLine,
          dataLineAttributes: options.dataLineAttributes
        }
      );
    } else {
      inner = renderTokensToHtml(semanticTokens, renderOpts);
    }
    if (options.wrapInPre) {
      return wrapInPre(inner, options);
    }
    return inner;
  }
  function wrapInPre(inner, options) {
    var _a, _b;
    const langClass = options.language ? ` hlts-lang-${options.language}` : "";
    const themeStyle = options.theme ? ` style="background:${(_a = options.theme.background) != null ? _a : ""};color:${(_b = options.theme.foreground) != null ? _b : ""}"` : "";
    return `<pre class="hlts${langClass}"${themeStyle}><code>${inner}</code></pre>`;
  }

  // demos/browser-entry.ts
  var demoApi = {
    builtinThemes,
    highlight,
    highlightDiff,
    diffModel,
    extractSymbols,
    registerProfile
  };
  var root = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : void 0;
  if (root && typeof root === "object") {
    root.TreeSitterTSHighlightDemo = demoApi;
  }
  return __toCommonJS(browser_entry_exports);
})();
//# sourceMappingURL=demo.iife.js.map
window.__TS_DEMO_BUNDLE_OK__ = true;
} catch (error) {
window.__TS_DEMO_BUNDLE_ERROR__ = String(error && error.stack ? error.stack : error);
}
  </script>
</head>
<body>
  <div class="container">
    <h1>tree-sitter-ts-highlight</h1>
    <p class="subtitle">Interactive playground: select language/theme, toggle semantic highlighting, compare source diffs, or paste your own code.</p>

    <div class="panel">
      <div class="controls">
        <div>
          <label for="language">Language</label>
          <select id="language"></select>
        </div>
        <div>
          <label for="theme">Theme</label>
          <select id="theme"></select>
        </div>
        <div>
          <label>&nbsp;</label>
          <button id="renderBtn" type="button">Render</button>
        </div>
      </div>
      <div class="row" style="margin-top:12px">
        <label class="check"><input id="semantic" type="checkbox" checked /> Semantic highlighting</label>
        <label class="check"><input id="lineNumbers" type="checkbox" checked /> Line numbers</label>
        <label class="check"><input id="customInput" type="checkbox" /> Use custom input</label>
        <button id="dslBtn" type="button">Register custom DSL profile</button>
      </div>
      <p class="small" style="margin-top:10px">Tip: run <strong>npm run build</strong> then <strong>npm run demo:generate</strong> to refresh this self-contained offline demo.</p>
    </div>

    <div class="panel">
      <label for="source">Source code</label>
      <textarea id="source"></textarea>
    </div>

    <div class="panel">
      <h2>Diff Demo</h2>
      <p class="muted">Compare two source versions using <strong>side-by-side</strong> or <strong>inline</strong> mode, and inspect the wrapper-friendly <strong>diffModel()</strong> output.</p>
      <div class="controls" style="margin-bottom:12px">
        <div>
          <label for="diffView">Diff view</label>
          <select id="diffView">
            <option value="side-by-side">Side by side</option>
            <option value="inline">Inline</option>
          </select>
        </div>
      </div>
      <div class="grid-2" style="margin-bottom:12px">
        <div>
          <label for="diffOld">Original source</label>
          <textarea id="diffOld"></textarea>
        </div>
        <div>
          <label for="diffNew">Updated source</label>
          <textarea id="diffNew"></textarea>
        </div>
      </div>
      <div class="diff-preview" id="diffPreview"></div>
      <h2 style="margin-top:16px">Diff Model (for wrappers)</h2>
      <pre class="json-preview" id="diffModelPreview"></pre>
    </div>

    <div class="panel code-wrap">
      <h2>Selected Output</h2>
      <div id="preview"></div>
    </div>

    <div class="panel">
      <h2>Why use this library?</h2>
      <p class="muted">Compared with regex-based highlighters, this demo shows tree-sitter-ts benefits in practice:</p>
      <ul>
        <li>Semantic reclassification (same token stream, richer visual contrast for properties/types/variables).</li>
        <li>Language profile extension at runtime (register custom DSL without plugin recompilation).</li>
        <li>Code structure extraction via <strong>extractSymbols()</strong> for editor-like features.</li>
      </ul>
    </div>

    <div class="grid-2">
      <div class="panel code-wrap">
        <h2>Comparison: semantic OFF</h2>
        <div id="previewOff"></div>
      </div>
      <div class="panel code-wrap">
        <h2>Comparison: semantic ON</h2>
        <div id="previewOn"></div>
      </div>
    </div>

    <div class="panel">
      <h2>Extracted Symbols</h2>
      <p class="muted">Live output from <strong>extractSymbols(source, language)</strong> for the current code.</p>
      <table class="symbols-table">
        <thead>
          <tr><th>Kind</th><th>Name</th><th>Start</th><th>End</th></tr>
        </thead>
        <tbody id="symbolsBody"></tbody>
      </table>
    </div>
  </div>

  <script>
    function normalizeDemoApi(candidate) {
      if (!candidate || typeof candidate !== "object") return undefined;
      if (
        typeof candidate.highlight === "function" &&
        typeof candidate.highlightDiff === "function" &&
        typeof candidate.diffModel === "function" &&
        Array.isArray(candidate.builtinThemes)
      ) {
        return candidate;
      }
      if ("demoApi" in candidate) {
        const unwrapped = candidate.demoApi;
        if (
          unwrapped &&
          typeof unwrapped === "object" &&
          typeof unwrapped.highlight === "function" &&
          typeof unwrapped.highlightDiff === "function" &&
          typeof unwrapped.diffModel === "function"
        ) {
          return unwrapped;
        }
      }
      return undefined;
    }

    const fromGlobalThisRaw = typeof globalThis !== "undefined" ? globalThis.TreeSitterTSHighlightDemo : undefined;
    const fromWindowRaw = typeof window !== "undefined" ? window.TreeSitterTSHighlightDemo : undefined;
    const fromVarRaw = typeof TreeSitterTSHighlightDemo !== "undefined" ? TreeSitterTSHighlightDemo : undefined;
    const demoApi = normalizeDemoApi(fromGlobalThisRaw) || normalizeDemoApi(fromWindowRaw) || normalizeDemoApi(fromVarRaw);
    if (!demoApi) {
      const bundleOk = typeof window !== "undefined" ? window.__TS_DEMO_BUNDLE_OK__ : undefined;
      const bundleError = typeof window !== "undefined" ? window.__TS_DEMO_BUNDLE_ERROR__ : undefined;
      throw new Error("Missing embedded demo bundle. Run npm run build && npm run demo:generate. bundleOk=" + String(bundleOk) + " bundleError=" + String(bundleError));
    }

    const { builtinThemes, highlight, highlightDiff, diffModel, extractSymbols, registerProfile } = demoApi;

    const samples = {"typescript":{"label":"TypeScript","code":"import { readFile } from \"node:fs/promises\";\n\ninterface Config {\n  port: number;\n  host: string;\n  debug?: boolean;\n}\n\nexport class Server {\n  constructor(private config: Config) {}\n\n  start(): void {\n    const { host, port } = this.config;\n    console.log(\"Server running at \" + host + \":\" + port);\n  }\n}\n\nexport function createServer(port = 3000): Server {\n  return new Server({ port, host: \"localhost\", debug: true });\n}"},"javascript":{"label":"JavaScript","code":"const users = [\n  { name: \"Ada\", age: 31 },\n  { name: \"Lin\", age: 17 },\n];\n\nfunction getAdults(list) {\n  return list.filter((item) => item.age >= 18).map((item) => item.name);\n}\n\nconsole.log(getAdults(users));"},"python":{"label":"Python","code":"from dataclasses import dataclass\n\n@dataclass\nclass User:\n    name: str\n    active: bool = True\n\n\ndef greet(user: User) -> str:\n    if user.active:\n        return f\"Hello, {user.name}!\"\n    return \"Inactive user\""},"go":{"label":"Go","code":"package main\n\nimport \"fmt\"\n\ntype User struct {\n    Name string\n    Age  int\n}\n\nfunc main() {\n    user := User{Name: \"Go\", Age: 16}\n    fmt.Println(user)\n}"},"rust":{"label":"Rust","code":"struct User {\n    name: String,\n    age: u32,\n}\n\nfn main() {\n    let user = User { name: String::from(\"Rust\"), age: 8 };\n    println!(\"{} {}\", user.name, user.age);\n}"},"java":{"label":"Java","code":"public class Main {\n  static class User {\n    String name;\n    int age;\n\n    User(String name, int age) {\n      this.name = name;\n      this.age = age;\n    }\n  }\n\n  public static void main(String[] args) {\n    User user = new User(\"Java\", 30);\n    System.out.println(user.name + \" \" + user.age);\n  }\n}"},"csharp":{"label":"C#","code":"using System;\n\nrecord User(string Name, int Age);\n\nvar user = new User(\"CSharp\", 20);\nConsole.WriteLine($\"{user.Name} {user.Age}\");"},"cpp":{"label":"C++","code":"#include <iostream>\n\nclass User {\npublic:\n  std::string name;\n  int age;\n\n  User(std::string n, int a) : name(n), age(a) {}\n};\n\nint main() {\n  User user(\"CPP\", 40);\n  std::cout << user.name << \" \" << user.age << std::endl;\n}"},"ruby":{"label":"Ruby","code":"class User\n  attr_reader :name, :age\n\n  def initialize(name, age)\n    @name = name\n    @age = age\n  end\nend\n\nuser = User.new(\"Ruby\", 28)\nputs \"#{user.name} #{user.age}\""},"php":{"label":"PHP","code":"<?php\nclass User {\n  public function __construct(\n    public string $name,\n    public int $age\n  ) {}\n}\n\n$user = new User(\"PHP\", 23);\necho $user->name . \" \" . $user->age;"},"kotlin":{"label":"Kotlin","code":"data class User(val name: String, val age: Int)\n\nfun main() {\n    val user = User(\"Kotlin\", 12)\n    println(\"${user.name} ${user.age}\")\n}"},"swift":{"label":"Swift","code":"struct User {\n    let name: String\n    let age: Int\n}\n\nlet user = User(name: \"Swift\", age: 11)\nprint(\"(user.name) (user.age)\")"},"css":{"label":"CSS","code":":root {\n  --accent: #7aa2f7;\n}\n\n.card {\n  color: var(--accent);\n  border: 1px solid #2a2a3a;\n}"},"html":{"label":"HTML","code":"<section class=\"card\">\n  <h1>Demo</h1>\n  <p data-id=\"42\">Hello</p>\n</section>"},"json":{"label":"JSON","code":"{\n  \"name\": \"json-demo\",\n  \"enabled\": true,\n  \"ports\": [3000, 3001],\n  \"meta\": { \"owner\": \"team\" }\n}"},"yaml":{"label":"YAML","code":"name: yaml-demo\nenabled: true\nports:\n  - 3000\n  - 3001\nmeta:\n  owner: team"},"sql":{"label":"SQL","code":"SELECT id, name\nFROM users\nWHERE active = true\nORDER BY created_at DESC\nLIMIT 10;"},"shell":{"label":"Shell","code":"#!/usr/bin/env bash\nset -euo pipefail\n\nname=\"demo\"\necho \"running $name\""},"markdown":{"label":"Markdown","code":"# Demo\n\n- **Bold** item\n- Inline code: `npm run build`\n\n> Quote"},"xml":{"label":"XML","code":"<users>\n  <user id=\"1\" active=\"true\">Alice</user>\n  <user id=\"2\" active=\"false\">Bob</user>\n</users>"},"toml":{"label":"TOML","code":"# TOML demo config\ntitle = \"tree-sitter-ts-highlight\"\nenabled = true\ntimeout = 30\npi = 3.14159\nhosts = [\"alpha\", \"beta\"]\n\n[database]\nserver = \"192.168.1.1\"\nports = [8001, 8001, 8002]\nconnection_max = 5000\n\n[owner]\nname = \"Tom Preston-Werner\"\ndob = 1979-05-27T07:32:00Z"}};
    const defaultThemeNames = ["default-light","default-dark","github-light","github-dark","monokai","dracula","nord","solarized-light","solarized-dark","tokyo-night","catppuccin-mocha"];

    const languageSelect = document.getElementById("language");
    const themeSelect = document.getElementById("theme");
    const sourceArea = document.getElementById("source");
    const renderBtn = document.getElementById("renderBtn");
    const semanticInput = document.getElementById("semantic");
    const lineNumbersInput = document.getElementById("lineNumbers");
    const customInput = document.getElementById("customInput");
    const dslBtn = document.getElementById("dslBtn");
    const diffView = document.getElementById("diffView");
    const diffOld = document.getElementById("diffOld");
    const diffNew = document.getElementById("diffNew");

    const preview = document.getElementById("preview");
    const previewOff = document.getElementById("previewOff");
    const previewOn = document.getElementById("previewOn");
    const symbolsBody = document.getElementById("symbolsBody");
    const diffPreview = document.getElementById("diffPreview");
    const diffModelPreview = document.getElementById("diffModelPreview");

    const themeMap = new Map(builtinThemes.map((theme) => [theme.name, theme]));

    const dslCode = "# Pipeline DSL sample\npipeline deploy {\n  stage build {\n    step compile\n    step test\n  }\n\n  stage release {\n    when env.TARGET = \"prod\"\n    step publish\n  }\n}";
    const dslProfile = {"name":"pipeline-dsl","displayName":"Pipeline DSL","version":"1.0.0","fileExtensions":[".pipe"],"lexer":{"charClasses":{"identStart":{"union":[{"predefined":"letter"},{"chars":"_"}]},"identPart":{"union":[{"predefined":"alphanumeric"},{"chars":"_-"}]}},"tokenTypes":{"keyword":{"category":"keyword"},"identifier":{"category":"identifier"},"string":{"category":"string"},"number":{"category":"number"},"comment":{"category":"comment"},"operator":{"category":"operator"},"punctuation":{"category":"punctuation"},"type":{"category":"type"},"whitespace":{"category":"whitespace"},"newline":{"category":"newline"}},"initialState":"default","skipTokens":["whitespace","newline"],"states":{"default":{"rules":[{"match":{"kind":"keywords","words":["pipeline","stage","step","when","env"]},"token":"keyword"},{"match":{"kind":"keywords","words":["String","Number","Boolean","File"]},"token":"type"},{"match":{"kind":"line","start":"#"},"token":"comment"},{"match":{"kind":"delimited","open":"\"","close":"\"","escape":"\\"},"token":"string"},{"match":{"kind":"number","integer":true,"float":true},"token":"number"},{"match":{"kind":"string","value":["->","=>","|","="]},"token":"operator"},{"match":{"kind":"string","value":["{","}","(",")","[","]",",",":",";","."]},"token":"punctuation"},{"match":{"kind":"charSequence","first":{"ref":"identStart"},"rest":{"ref":"identPart"}},"token":"identifier"},{"match":{"kind":"charSequence","first":{"predefined":"whitespace"},"rest":{"predefined":"whitespace"}},"token":"whitespace"},{"match":{"kind":"string","value":"\n"},"token":"newline"}]}}}};
    const diffSamples = {
      typescript: {
        oldSource: 'interface User {\n  id: number;\n  name: string;\n}\n\nexport function formatUser(user: User): string {\n  return user.name;\n}',
        newSource: 'interface User {\n  id: number;\n  name: string;\n  email?: string;\n}\n\nexport function formatUser(user: User): string {\n  return user.name + " <" + (user.email ?? "n/a") + ">";\n}',
      },
      javascript: {
        oldSource: 'function sum(items) {\n  return items.reduce((acc, item) => acc + item, 0);\n}',
        newSource: 'export function sum(items) {\n  if (!Array.isArray(items)) return 0;\n  return items.reduce((acc, item) => acc + item, 0);\n}',
      },
      python: {
        oldSource: 'def greet(name):\n    return "Hello " + name',
        newSource: 'def greet(name: str) -> str:\n    if not name:\n        return "Hello"\n    return f"Hello {name}"',
      },
    };

    function fillLanguages() {
      const entries = Object.entries(samples);
      languageSelect.innerHTML = entries
        .map(([id, item]) => '<option value="' + id + '">' + item.label + '</option>')
        .join("");
    }

    function fillThemes() {
      themeSelect.innerHTML = defaultThemeNames
        .map((name) => '<option value="' + name + '">' + name + '</option>')
        .join("");
    }

    function getSelectedCode() {
      const lang = languageSelect.value;
      if (customInput.checked) return sourceArea.value;
      return samples[lang] ? samples[lang].code : "";
    }

    function setSourceFromLanguage() {
      if (!customInput.checked) {
        sourceArea.value = samples[languageSelect.value] ? samples[languageSelect.value].code : "";
      }
    }

    function renderCode(html, theme) {
      const themeClass = theme && theme.name ? ' hlts-' + theme.name : '';
      return '<pre class="hlts' + themeClass + '"><code>' + html + '</code></pre>';
    }

    function escapeHtml(value) {
      return String(value)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function setDiffFromLanguage() {
      const language = languageSelect.value;
      const sample = diffSamples[language] || {
        oldSource: (samples[language] ? samples[language].code : "").split("\n").slice(0, 12).join("\n"),
        newSource: (samples[language] ? samples[language].code : "").split("\n").slice(0, 12).join("\n") + "\n",
      };
      diffOld.value = sample.oldSource;
      diffNew.value = sample.newSource;
    }

    function renderDiff(language, theme) {
      const oldSource = diffOld.value;
      const newSource = diffNew.value;
      try {
        const html = highlightDiff(oldSource, newSource, language, {
          view: diffView.value,
          semanticHighlighting: semanticInput.checked,
        });
        const themeClass = theme && theme.name ? ' hlts-' + theme.name : '';
        diffPreview.innerHTML = '<div class="hlts' + themeClass + '">' + html + '</div>';

        const model = diffModel(oldSource, newSource, {
          oldLabel: "Original",
          newLabel: "Updated",
        });
        const compact = {
          oldLabel: model.oldLabel,
          newLabel: model.newLabel,
          totalRows: model.rows.length,
          rows: model.rows.slice(0, 12),
        };
        diffModelPreview.innerHTML = escapeHtml(JSON.stringify(compact, null, 2));
      } catch (error) {
        diffPreview.innerHTML = '<pre class="hlts" style="background:#2b1d24;color:#ffb4c1"><code>' + escapeHtml(String(error)) + '</code></pre>';
        diffModelPreview.textContent = String(error);
      }
    }

    function renderSymbols(source, language) {
      try {
        const symbols = extractSymbols(source, language);
        if (!symbols.length) {
          symbolsBody.innerHTML = '<tr><td colspan="4" class="muted">No symbols extracted for this sample.</td></tr>';
          return;
        }

        symbolsBody.innerHTML = symbols
          .slice(0, 24)
          .map((symbol) =>
            '<tr><td>' + symbol.kind + '</td><td>' + symbol.name + '</td><td>' + symbol.startLine + '</td><td>' + symbol.endLine + '</td></tr>'
          )
          .join("");
      } catch (error) {
        symbolsBody.innerHTML = '<tr><td colspan="4" class="muted">Symbol extraction is unavailable: ' + String(error) + '</td></tr>';
      }
    }

    function renderAll() {
      const language = languageSelect.value;
      const source = getSelectedCode();
      const theme = themeMap.get(themeSelect.value) || builtinThemes[0];
      const withLineNumbers = lineNumbersInput.checked;

      try {
        const selectedHtml = highlight(source, language, {
          lineNumbers: withLineNumbers,
          semanticHighlighting: semanticInput.checked,
        });
        const baseHtml = highlight(source, language, {
          lineNumbers: withLineNumbers,
          semanticHighlighting: false,
        });
        const semanticHtml = highlight(source, language, {
          lineNumbers: withLineNumbers,
          semanticHighlighting: true,
        });

        preview.innerHTML = renderCode(selectedHtml, theme);
        previewOff.innerHTML = renderCode(baseHtml, theme);
        previewOn.innerHTML = renderCode(semanticHtml, theme);
      } catch (error) {
        const message = String(error);
        preview.innerHTML = '<pre class="hlts" style="background:#2b1d24;color:#ffb4c1"><code>' + message + '</code></pre>';
        previewOff.innerHTML = "";
        previewOn.innerHTML = "";
      }

      renderSymbols(source, language);
      renderDiff(language, theme);
    }

    dslBtn.addEventListener("click", () => {
      if (!samples["pipeline-dsl"]) {
        registerProfile(dslProfile);
        samples["pipeline-dsl"] = { label: "Pipeline DSL (custom)", code: dslCode };
        fillLanguages();
        languageSelect.value = "pipeline-dsl";
        customInput.checked = false;
        setSourceFromLanguage();
        setDiffFromLanguage();
        renderAll();
      }
    });

    renderBtn.addEventListener("click", renderAll);
    languageSelect.addEventListener("change", () => {
      setSourceFromLanguage();
      setDiffFromLanguage();
      renderAll();
    });
    themeSelect.addEventListener("change", renderAll);
    semanticInput.addEventListener("change", renderAll);
    lineNumbersInput.addEventListener("change", renderAll);
    diffView.addEventListener("change", renderAll);
    diffOld.addEventListener("input", renderAll);
    diffNew.addEventListener("input", renderAll);
    customInput.addEventListener("change", () => {
      if (!customInput.checked) {
        setSourceFromLanguage();
      }
      sourceArea.readOnly = !customInput.checked;
      renderAll();
    });
    sourceArea.addEventListener("input", () => {
      if (customInput.checked) {
        renderAll();
      }
    });

    fillLanguages();
    fillThemes();
    languageSelect.value = "typescript";
    themeSelect.value = "github-dark";
    sourceArea.readOnly = true;
    setSourceFromLanguage();
    setDiffFromLanguage();
    renderAll();
  </script>
</body>
</html>